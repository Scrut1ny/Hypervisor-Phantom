diff --git a/hw/acpi/aml-build.c b/hw/acpi/aml-build.c
index 2d5826a..7cd88c2 100644
--- a/hw/acpi/aml-build.c
+++ b/hw/acpi/aml-build.c
@@ -1722,11 +1722,11 @@ void acpi_table_begin(AcpiTable *desc, GArray *array)
     build_append_int_noprefix(array, 0, 4); /* Length */
     build_append_int_noprefix(array, desc->rev, 1); /* Revision */
     build_append_int_noprefix(array, 0, 1); /* Checksum */
-    build_append_padded_str(array, desc->oem_id, 6, '\0'); /* OEMID */
+    build_append_padded_str(array, ACPI_BUILD_APPNAME6, 6, '\0'); /* OEMID */
     /* OEM Table ID */
-    build_append_padded_str(array, desc->oem_table_id, 8, '\0');
+    build_append_padded_str(array, ACPI_BUILD_APPNAME8, 8, '\0');
     build_append_int_noprefix(array, 1, 4); /* OEM Revision */
-    g_array_append_vals(array, ACPI_BUILD_APPNAME8, 4); /* Creator ID */
+    g_array_append_vals(array, "ACPI", 4); /* Creator ID */
     build_append_int_noprefix(array, 1, 4); /* Creator Revision */
 }
 
@@ -2263,7 +2263,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     /* ACPI1.0: INT_MODEL, ACPI2.0+: Reserved */
     build_append_int_noprefix(tbl, f->int_model /* Multiple APIC */, 1);
     /* Preferred_PM_Profile */
-    build_append_int_noprefix(tbl, 0 /* Unspecified */, 1);
+    build_append_int_noprefix(tbl, 1 /* Desktop */, 1);
     build_append_int_noprefix(tbl, f->sci_int, 2); /* SCI_INT */
     build_append_int_noprefix(tbl, f->smi_cmd, 4); /* SMI_CMD */
     build_append_int_noprefix(tbl, f->acpi_enable_cmd, 1); /* ACPI_ENABLE */
@@ -2360,7 +2360,7 @@ void build_fadt(GArray *tbl, BIOSLinker *linker, const AcpiFadtData *f,
     }
 
     /* Hypervisor Vendor Identity */
-    build_append_padded_str(tbl, "QEMU", 8, '\0');
+    build_append_padded_str(tbl, "", 8, '\0');
 
     /* TODO: extra fields need to be added to support revisions above rev6 */
     assert(f->rev == 6);
diff --git a/hw/acpi/pcihp.c b/hw/acpi/pcihp.c
index 4922bbc..2b86b9d 100644
--- a/hw/acpi/pcihp.c
+++ b/hw/acpi/pcihp.c
@@ -701,6 +701,83 @@ void build_append_pcihp_resources(Aml *scope /* \\_SB.PCI0 */,
     aml_append(scope, dev);
 }
 
+/*
+ * Helper to generate "Real Hardware" looking ACPI names.
+ * This removes the "S<hex>" signature and ensures unique naming
+ * for multifunction devices.
+ */
+static void get_mimic_pci_name(char *name, int devfn) {
+    int slot = PCI_SLOT(devfn);
+    int func = PCI_FUNC(devfn);
+
+    switch (slot) {
+        case 0:
+            // Host Bridge is almost always Slot 0, Function 0 (and also bus 0 but we cant access bus number in this context)
+            if (func == 0) sprintf(name, "MCHC");
+            else sprintf(name, "H%X", func);
+            break;
+
+        case 2:
+            // Slot 2: Graphics + associated HDMI Audio
+            if (func == 0) sprintf(name, "GFX0");      // Primary GPU
+            else if (func == 1) sprintf(name, "HDAU"); // HDMI Audio
+            else sprintf(name, "GFX%X", func);         // Fallback uniqueness
+            break;
+
+        case 3:
+            // Slot 3: Network
+            if (func == 0) sprintf(name, "GLAN");
+            else sprintf(name, "NET%X", func);
+            break;
+
+        case 4:
+            // Slot 4: Multimedia / Audio
+            if (func == 0) sprintf(name, "HDEF");
+            else sprintf(name, "MM%02X", func);
+            break;
+
+        case 5:
+            // Slot 5: USB XHCI (QEMU default often)
+            if (func == 0) sprintf(name, "XHC1");
+            else sprintf(name, "XHC%X", func);
+            break;
+
+        case 6:
+            // Slot 6: SATA (AHCI)
+            if (func == 0) sprintf(name, "SAT0");
+            else sprintf(name, "SAT%X", func);
+            break;
+
+        case 29:
+            // Slot 29 (0x1D): USB EHCI (Intel Standard)
+            if (func == 0) sprintf(name, "EHC1");
+            else sprintf(name, "EHC%X", func);
+            break;
+
+        case 31:
+            // Slot 31 (0x1F): LPC / SMBus / SATA 2
+            if (func == 0) sprintf(name, "LPCB");      // ISA Bridge
+            else if (func == 2) sprintf(name, "SAT1"); // 2nd SATA
+            else if (func == 3) sprintf(name, "SBUS"); // SMBus
+            else sprintf(name, "S31%X", func);         // Fallback
+            break;
+
+        default:
+            /*
+             * For generic slots, we use "RP" (Root Port) + devfn (Hex).
+             *
+             * Why 'devfn' and not 'slot'?
+             * - Slot 10, Func 0 (devfn 0x50) -> RP50
+             * - Slot 10, Func 1 (devfn 0x51) -> RP51
+             *
+             * This guarantees ACPI uniqueness for multifunction devices
+             * while completely breaking the "S" + hex signature.
+             */
+            sprintf(name, "RP%02X", devfn);
+            break;
+    }
+}
+
 bool build_append_notification_callback(Aml *parent_scope, const PCIBus *bus)
 {
     Aml *method;
@@ -710,7 +787,10 @@ bool build_append_notification_callback(Aml *parent_scope, const PCIBus *bus)
     GQueue *pcnt_bus_list = g_queue_new();
 
     QLIST_FOREACH(sec, &bus->child, sibling) {
-        Aml *br_scope = aml_scope("S%.02X", sec->parent_dev->devfn);
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, sec->parent_dev->devfn);
+        Aml *br_scope = aml_scope("%s", mimic_name);
+
         if (pci_bus_is_root(sec)) {
             continue;
         }
@@ -749,7 +829,9 @@ bool build_append_notification_callback(Aml *parent_scope, const PCIBus *bus)
 
     /* Notify about child bus events in any case */
     while ((sec = g_queue_pop_head(pcnt_bus_list))) {
-        aml_append(method, aml_name("^S%.02X.PCNT", sec->parent_dev->devfn));
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, sec->parent_dev->devfn);
+        aml_append(method, aml_name("^%s.PCNT", mimic_name));
     }
 
     aml_append(parent_scope, method);
@@ -805,8 +887,10 @@ static void build_append_pcihp_notify_entry(Aml *method, int slot)
     Aml *if_ctx;
     int32_t devfn = PCI_DEVFN(slot, 0);
 
+    char mimic_name[5];
+    get_mimic_pci_name(mimic_name, devfn);
     if_ctx = aml_if(aml_and(aml_arg(0), aml_int(0x1U << slot), NULL));
-    aml_append(if_ctx, aml_notify(aml_name("S%.02X", devfn), aml_arg(1)));
+    aml_append(if_ctx, aml_notify(aml_name("%s", mimic_name), aml_arg(1)));
     aml_append(method, if_ctx);
 }
 
@@ -869,10 +953,13 @@ void build_append_pcihp_slots(Aml *parent_scope, PCIBus *bus)
             continue;
         }
 
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, devfn);
+
         if (bus->devices[devfn]) {
-            dev = aml_scope("S%.02X", devfn);
+            dev = aml_scope("%s", mimic_name);
         } else {
-            dev = aml_device("S%.02X", devfn);
+            dev = aml_device("%s", mimic_name);
             aml_append(dev, aml_name_decl("_ADR", aml_int(adr)));
         }
 
@@ -914,7 +1001,11 @@ void build_append_pci_bus_devices(Aml *parent_scope, PCIBus *bus)
         }
 
         /* start to compose PCI device descriptor */
-        dev = aml_device("S%.02X", devfn);
+
+        char mimic_name[5];
+        get_mimic_pci_name(mimic_name, devfn);
+        dev = aml_device("%s", mimic_name);
+
         aml_append(dev, aml_name_decl("_ADR", aml_int(adr)));
 
         call_dev_aml_func(DEVICE(bus->devices[devfn]), dev);
diff --git a/hw/audio/hda-codec.c b/hw/audio/hda-codec.c
index e90c9de..5b147d6 100644
--- a/hw/audio/hda-codec.c
+++ b/hw/audio/hda-codec.c
@@ -118,7 +118,7 @@ static void hda_codec_parse_fmt(uint32_t format, struct audsettings *as)
 
 /* some defines */
 
-#define QEMU_HDA_ID_VENDOR  0x1af4
+#define QEMU_HDA_ID_VENDOR  0x10EC /* Realtek HDA Codec Vendor ID */
 #define QEMU_HDA_PCM_FORMATS (AC_SUPPCM_BITS_16 |       \
                               0x1fc /* 16 -> 96 kHz */)
 #define QEMU_HDA_AMP_NONE    (0)
diff --git a/hw/audio/intel-hda.c b/hw/audio/intel-hda.c
index 758e130..78a4e0f 100644
--- a/hw/audio/intel-hda.c
+++ b/hw/audio/intel-hda.c
@@ -1239,7 +1239,7 @@ static void intel_hda_class_init_ich6(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x2668;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH6 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x2668 | hw/audio/intel-hda.c
     k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich6)";
@@ -1250,8 +1250,8 @@ static void intel_hda_class_init_ich9(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->device_id = 0x293e;
-    k->revision = 3;
+    k->device_id = 0x51c8; // "Intel 82801IB ICH9 - High Definition Audio [A3]" | Intel Device ID Replacement from 0x293e | hw/audio/intel-hda.c
+    k->revision = 1;
     set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
     dc->desc = "Intel HD Audio Controller (ich9)";
 }
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index fab42a7..ed5052b 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -774,7 +774,7 @@ static void device_class_init(ObjectClass *class, const void *data)
      * hotpluggable. Devices that shouldn't be hotpluggable,
      * should override it in their class_init()
      */
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     dc->user_creatable = true;
     vc->get_id = device_vmstate_if_get_id;
     rc->get_state = device_get_reset_state;
diff --git a/hw/display/edid-generate.c b/hw/display/edid-generate.c
index 2cb8196..630a33b 100644
--- a/hw/display/edid-generate.c
+++ b/hw/display/edid-generate.c
@@ -388,22 +388,22 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint8_t *did = NULL;
     uint32_t width_mm, height_mm;
     uint32_t refresh_rate = info->refresh_rate ? info->refresh_rate : 75000;
-    uint32_t dpi = 100; /* if no width_mm/height_mm */
+    uint32_t dpi = 82; /* if no width_mm/height_mm */
     uint32_t large_screen = 0;
 
     /* =============== set defaults  =============== */
 
     if (!info->vendor || strlen(info->vendor) != 3) {
-        info->vendor = "RHT";
+        info->vendor = "MSI";
     }
     if (!info->name) {
-        info->name = "QEMU Monitor";
+        info->name = "G27C4X";
     }
     if (!info->prefx) {
-        info->prefx = 1280;
+        info->prefx = 1920;
     }
     if (!info->prefy) {
-        info->prefy = 800;
+        info->prefy = 1080;
     }
     if (info->width_mm && info->height_mm) {
         width_mm = info->width_mm;
@@ -449,15 +449,15 @@ void qemu_edid_generate(uint8_t *edid, size_t size,
     uint16_t vendor_id = ((((info->vendor[0] - '@') & 0x1f) << 10) |
                           (((info->vendor[1] - '@') & 0x1f) <<  5) |
                           (((info->vendor[2] - '@') & 0x1f) <<  0));
-    uint16_t model_nr = 0x1234;
+    uint16_t model_nr = 0x10ad;
     uint32_t serial_nr = info->serial ? atoi(info->serial) : 0;
     stw_be_p(edid +  8, vendor_id);
     stw_le_p(edid + 10, model_nr);
     stl_le_p(edid + 12, serial_nr);
 
     /* manufacture week and year */
-    edid[16] = 42;
-    edid[17] = 2014 - 1990;
+    edid[16] = 12;
+    edid[17] = 2025 - 2018;
 
     /* edid version */
     edid[18] = 1;
diff --git a/hw/display/qxl.c b/hw/display/qxl.c
index 18f482c..6679592 100644
--- a/hw/display/qxl.c
+++ b/hw/display/qxl.c
@@ -2503,7 +2503,7 @@ static void qxl_pci_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
 
-    k->vendor_id = REDHAT_PCI_VENDOR_ID;
+    k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = QXL_DEVICE_ID_STABLE;
     set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
     device_class_set_legacy_reset(dc, qxl_reset_handler);
diff --git a/hw/i2c/smbus_ich9.c b/hw/i2c/smbus_ich9.c
index 956c9b5..c91c1c4 100644
--- a/hw/i2c/smbus_ich9.c
+++ b/hw/i2c/smbus_ich9.c
@@ -124,12 +124,12 @@ static void ich9_smb_class_init(ObjectClass *klass, const void *data)
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
     AcpiDevAmlIfClass *adevc = ACPI_DEV_AML_IF_CLASS(klass);
 
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
+    k->vendor_id = PCI_VENDOR_ID_AMD;
     k->device_id = PCI_DEVICE_ID_INTEL_ICH9_6;
     k->revision = ICH9_A2_SMB_REVISION;
     k->class_id = PCI_CLASS_SERIAL_SMBUS;
     dc->vmsd = &vmstate_ich9_smbus;
-    dc->desc = "ICH9 SMBUS Bridge";
+    dc->desc = "FCH SMBus Controller";
     k->realize = ich9_smbus_realize;
     k->config_write = ich9_smbus_write_config;
     /*
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index 9446a9f..f354b28 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -161,8 +161,8 @@ static void init_common_fadt_data(MachineState *ms, Object *o,
                         (1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL) : 0),
         .int_model = 1 /* Multiple APIC */,
         .rtc_century = RTC_CENTURY,
-        .plvl2_lat = 0xfff /* C2 state not supported */,
-        .plvl3_lat = 0xfff /* C3 state not supported */,
+        .plvl2_lat = 0x0065 /* C2 state not supported */,
+        .plvl3_lat = 0x03e9 /* C3 state not supported */,
         .smi_cmd = smm_enabled ? ACPI_PORT_SMI_CMD : 0,
         .sci_int = object_property_get_uint(o, ACPI_PM_PROP_SCI_INT, NULL),
         .acpi_enable_cmd =
@@ -881,6 +881,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     build_dbg_aml(dsdt);
     if (i440fx) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A03")));
         aml_append(dev, aml_name_decl("_UID", aml_int(pcmc->pci_root_uid)));
@@ -894,6 +956,68 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
         build_piix4_pci0_int(dsdt);
     } else if (q35) {
         sb_scope = aml_scope("_SB");
+
+        /*
+         * Emulate Windows ACPI OSYS/_OSI logic in DSDT.
+         * Adds Windows 2001/2006/2009/2012/2013/2015.
+         */
+
+        aml_append(sb_scope, aml_name_decl("OSYS", aml_int(0x03E8)));
+
+        Aml *osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D1), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001 SP2")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D2), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2001.1")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D3), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2006")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D6), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2009")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07D9), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2012")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DC), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2013")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DD), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
+        osi = aml_if(
+            aml_equal(aml_call1("_OSI", aml_string("Windows 2015")), aml_int(1))
+        );
+        aml_append(osi, aml_store(aml_int(0x07DF), aml_name("OSYS")));
+        aml_append(sb_scope, osi);
+
         dev = aml_device("PCI0");
         aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A08")));
         aml_append(dev, aml_name_decl("_CID", aml_eisaid("PNP0A03")));
@@ -1186,7 +1310,7 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
     /* create fw_cfg node, unconditionally */
     {
         scope = aml_scope("\\_SB.PCI0");
-        fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg);
+        //fw_cfg_add_acpi_dsdt(scope, x86ms->fw_cfg); Fix compile error
         aml_append(dsdt, scope);
     }
 
@@ -1630,6 +1754,8 @@ build_dmar_q35(GArray *table_data, BIOSLinker *linker, const char *oem_id,
  *
  * Helpful to speedup Windows guests and ignored by others.
  */
+// Disable WAET device (not found on bare metal systems)
+#if 0
 static void
 build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
            const char *oem_table_id)
@@ -1648,6 +1774,7 @@ build_waet(GArray *table_data, BIOSLinker *linker, const char *oem_id,
     build_append_int_noprefix(table_data, 1 << 1 /* ACPI PM timer good */, 4);
     acpi_table_end(linker, &table);
 }
+#endif
 
 /*
  *   IVRS table as specified in AMD IOMMU Specification v2.62, Section 5.2
@@ -2076,8 +2203,9 @@ void acpi_build(AcpiBuildTables *tables, MachineState *machine)
                        x86ms->oem_id, x86ms->oem_table_id, &pcms->cxl_devices_state);
     }
 
-    acpi_add_table(table_offsets, tables_blob);
-    build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
+    // Disable WAET table (not found on bare metal systems)
+    // acpi_add_table(table_offsets, tables_blob);
+    // build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
 
     /* Add tables supplied by user (if any) */
     for (u = acpi_table_first(); u; u = acpi_table_next(u)) {
diff --git a/hw/i386/acpi-microvm.c b/hw/i386/acpi-microvm.c
index bc65717..f4b1bea 100644
--- a/hw/i386/acpi-microvm.c
+++ b/hw/i386/acpi-microvm.c
@@ -118,7 +118,7 @@ build_dsdt_microvm(GArray *table_data, BIOSLinker *linker,
     dsdt = init_aml_allocator();
 
     sb_scope = aml_scope("_SB");
-    fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg);
+    //fw_cfg_add_acpi_dsdt(sb_scope, x86ms->fw_cfg); Fix compile error
     qbus_build_aml(BUS(isabus), sb_scope);
     build_ged_aml(sb_scope, GED_DEVICE, x86ms->acpi_dev,
                   GED_MMIO_IRQ, AML_SYSTEM_MEMORY, GED_MMIO_BASE);
diff --git a/hw/i386/fw_cfg.c b/hw/i386/fw_cfg.c
index 5c0bcd5..ac47187 100644
--- a/hw/i386/fw_cfg.c
+++ b/hw/i386/fw_cfg.c
@@ -75,7 +75,7 @@ void fw_cfg_build_smbios(PCMachineState *pcms, FWCfgState *fw_cfg,
 
     if (pcmc->smbios_defaults) {
         /* These values are guest ABI, do not change */
-        smbios_set_defaults("QEMU", mc->desc, mc->name);
+        smbios_set_defaults("Unknown", mc->desc, mc->name);
     }
 
     /* tell smbios about cpuid version and features */
@@ -212,6 +212,8 @@ void fw_cfg_build_feature_control(MachineState *ms, FWCfgState *fw_cfg)
     fw_cfg_add_file(fw_cfg, "etc/msr_feature_control", val, sizeof(*val));
 }
 
+// Disable FWCF device (not found on bare metal systems)
+#if 0
 #ifdef CONFIG_ACPI
 void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
 {
@@ -240,3 +242,4 @@ void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
     aml_append(scope, dev);
 }
 #endif
+#endif
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index f8b919c..3e5fe11 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -1735,7 +1735,7 @@ static void pc_machine_class_init(ObjectClass *oc, const void *data)
 
     pcmc->pci_enabled = true;
     pcmc->has_acpi_build = true;
-    pcmc->smbios_defaults = true;
+    pcmc->smbios_defaults = false;
     pcmc->gigabyte_align = true;
     pcmc->has_reserved_memory = true;
     pcmc->enforce_amd_1tb_hole = true;
diff --git a/hw/ide/atapi.c b/hw/ide/atapi.c
index a42b748..c10cf51 100644
--- a/hw/ide/atapi.c
+++ b/hw/ide/atapi.c
@@ -798,8 +798,8 @@ static void cmd_inquiry(IDEState *s, uint8_t *buf)
         buf[5] = 0;    /* reserved */
         buf[6] = 0;    /* reserved */
         buf[7] = 0;    /* reserved */
-        padstr8(buf + 8, 8, "QEMU");
-        padstr8(buf + 16, 16, "QEMU DVD-ROM");
+        padstr8(buf + 8, 8, "Samsung");
+        padstr8(buf + 16, 16, "DVD-ROM");
         padstr8(buf + 32, 4, s->version);
         idx = 36;
     }
diff --git a/hw/ide/core.c b/hw/ide/core.c
index 8c380ab..edd4294 100644
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -2638,21 +2638,20 @@ int ide_init_drive(IDEState *s, IDEDevice *dev, IDEDriveKind kind, Error **errp)
     if (dev->serial) {
         pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), dev->serial);
     } else {
-        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),
-                 "QM%05d", s->drive_serial);
+        s->drive_serial_str[0] = '\0';  // Empty string fallback instead of QEMU default
     }
     if (dev->model) {
         pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), dev->model);
     } else {
         switch (kind) {
         case IDE_CD:
-            strcpy(s->drive_model_str, "QEMU DVD-ROM");
+            strcpy(s->drive_model_str, "HL-DT-ST BD-RE WH16NS60");
             break;
         case IDE_CFATA:
-            strcpy(s->drive_model_str, "QEMU MICRODRIVE");
+            strcpy(s->drive_model_str, "Hitachi HMS360404D5CF00");
             break;
         default:
-            strcpy(s->drive_model_str, "QEMU HARDDISK");
+            strcpy(s->drive_model_str, "Samsung SSD 980 500GB");
             break;
         }
     }
diff --git a/hw/ide/ich.c b/hw/ide/ich.c
index b00987f..438ec55 100644
--- a/hw/ide/ich.c
+++ b/hw/ide/ich.c
@@ -183,8 +183,8 @@ static void ich_ahci_class_init(ObjectClass *klass, const void *data)
 
     k->realize = pci_ich9_ahci_realize;
     k->exit = pci_ich9_uninit;
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
-    k->device_id = PCI_DEVICE_ID_INTEL_82801IR;
+    k->vendor_id = PCI_VENDOR_ID_AMD;
+    k->device_id = PCI_DEVICE_ID_AMD_SATA;
     k->revision = 0x02;
     k->class_id = PCI_CLASS_STORAGE_SATA;
     dc->vmsd = &vmstate_ich9_ahci;
diff --git a/hw/isa/lpc_ich9.c b/hw/isa/lpc_ich9.c
index c9cb8f7..bf99152 100644
--- a/hw/isa/lpc_ich9.c
+++ b/hw/isa/lpc_ich9.c
@@ -863,7 +863,7 @@ static void build_ich9_isa_aml(AcpiDevAmlIf *adev, Aml *scope)
     aml_append(scope, aml_operation_region("PIRQ", AML_PCI_CONFIG,
                                            aml_int(0x60), 0x0C));
     /* Fields declarion has to happen *after* operation region */
-    field = aml_field("PCI0.SF8.PIRQ", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);
+    field = aml_field("PCI0.LPCB.PIRQ", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);
     aml_append(field, aml_named_field("PRQA", 8));
     aml_append(field, aml_named_field("PRQB", 8));
     aml_append(field, aml_named_field("PRQC", 8));
@@ -893,8 +893,8 @@ static void ich9_lpc_class_init(ObjectClass *klass, const void *data)
     dc->vmsd = &vmstate_ich9_lpc;
     device_class_set_props(dc, ich9_lpc_properties);
     k->config_write = ich9_lpc_config_write;
-    dc->desc = "ICH9 LPC bridge";
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
+    dc->desc = "FCH LPC Bridge";
+    k->vendor_id = PCI_VENDOR_ID_AMD;
     k->device_id = PCI_DEVICE_ID_INTEL_ICH9_8;
     k->revision = ICH9_A2_LPC_REVISION;
     k->class_id = PCI_CLASS_BRIDGE_ISA;
diff --git a/hw/misc/pvpanic-isa.c b/hw/misc/pvpanic-isa.c
index f7b421c..881cf2b 100644
--- a/hw/misc/pvpanic-isa.c
+++ b/hw/misc/pvpanic-isa.c
@@ -69,7 +69,7 @@ static void build_pvpanic_isa_aml(AcpiDevAmlIf *adev, Aml *scope)
     PVPanicISAState *s = PVPANIC_ISA_DEVICE(adev);
     Aml *dev = aml_device("PEVT");
 
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0001")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0001")));
 
     crs = aml_resource_template();
     aml_append(crs,
diff --git a/hw/nvme/ctrl.c b/hw/nvme/ctrl.c
index cc4593c..b002b80 100644
--- a/hw/nvme/ctrl.c
+++ b/hw/nvme/ctrl.c
@@ -9094,7 +9094,7 @@ static void nvme_init_ctrl(NvmeCtrl *n, PCIDevice *pci_dev)
 
     id->vid = cpu_to_le16(pci_get_word(pci_conf + PCI_VENDOR_ID));
     id->ssvid = cpu_to_le16(pci_get_word(pci_conf + PCI_SUBSYSTEM_VENDOR_ID));
-    strpadcpy((char *)id->mn, sizeof(id->mn), "QEMU NVMe Ctrl", ' ');
+    strpadcpy((char *)id->mn, sizeof(id->mn), "NVMe Ctrl", ' ');
     strpadcpy((char *)id->fr, sizeof(id->fr), QEMU_VERSION, ' ');
     strpadcpy((char *)id->sn, sizeof(id->sn), n->params.serial, ' ');
 
diff --git a/hw/nvram/fw_cfg-acpi.c b/hw/nvram/fw_cfg-acpi.c
index 2e6ef89..bb5a6f4 100644
--- a/hw/nvram/fw_cfg-acpi.c
+++ b/hw/nvram/fw_cfg-acpi.c
@@ -11,7 +11,7 @@
 void fw_cfg_acpi_dsdt_add(Aml *scope, const MemMapEntry *fw_cfg_memmap)
 {
     Aml *dev = aml_device("FWCF");
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0002")));
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
     aml_append(dev, aml_name_decl("_CCA", aml_int(1)));
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index aa24050..3b903de 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -56,7 +56,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 struct FWCfgEntry {
     uint32_t len;
@@ -1002,7 +1002,7 @@ static void fw_cfg_common_realize(DeviceState *dev, Error **errp)
         return;
     }
 
-    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4);
+    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4); // "QEMU"
     fw_cfg_add_bytes(s, FW_CFG_UUID, &qemu_uuid, 16);
     fw_cfg_add_i16(s, FW_CFG_NOGRAPHIC, (uint16_t)!machine->enable_graphics);
     fw_cfg_add_i16(s, FW_CFG_BOOT_MENU, (uint16_t)(machine->boot_config.has_menu && machine->boot_config.menu));
diff --git a/hw/pci-host/gpex.c b/hw/pci-host/gpex.c
index b806a22..3713551 100644
--- a/hw/pci-host/gpex.c
+++ b/hw/pci-host/gpex.c
@@ -243,7 +243,7 @@ static void gpex_root_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
 
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
-    dc->desc = "QEMU generic PCIe host bridge";
+    dc->desc = "Generic PCIe host bridge";
     dc->vmsd = &vmstate_gpex_root;
     k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = PCI_DEVICE_ID_REDHAT_PCIE_HOST;
diff --git a/hw/pci-host/q35.c b/hw/pci-host/q35.c
index a708758..50896e0 100644
--- a/hw/pci-host/q35.c
+++ b/hw/pci-host/q35.c
@@ -679,7 +679,7 @@ static void mch_class_init(ObjectClass *klass, const void *data)
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
     dc->desc = "Host bridge";
     dc->vmsd = &vmstate_mch;
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
+    k->vendor_id = PCI_VENDOR_ID_AMD;
     /*
      * The 'q35' machine type implements an Intel Series 3 chipset,
      * of which there are several variants. The key difference between
diff --git a/hw/scsi/mptconfig.c b/hw/scsi/mptconfig.c
index 19d01f3..00ee3f8 100644
--- a/hw/scsi/mptconfig.c
+++ b/hw/scsi/mptconfig.c
@@ -189,12 +189,12 @@ static
 size_t mptsas_config_manufacturing_0(MPTSASState *s, uint8_t **data, int address)
 {
     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,
-                              "s16s8s16s16s16",
-                              "QEMU MPT Fusion",
+                              "s10s4s85s45s34",
+                              "MPT Fusion",
                               "2.5",
-                              "QEMU MPT Fusion",
-                              "QEMU",
-                              "0000111122223333");
+                              "MPT Fusion",
+                              "MSI",
+                              "7624862998526197");
 }
 
 static
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index b9b115d..1c55b40 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -698,8 +698,8 @@ static bool scsi_target_emulate_inquiry(SCSITargetReq *r)
         r->buf[3] = 2 | 0x10; /* HiSup, response data format */
         r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */
         r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */
-        memcpy(&r->buf[8], "QEMU    ", 8);
-        memcpy(&r->buf[16], "QEMU TARGET     ", 16);
+        memcpy(&r->buf[8], "MSI     ", 8);
+        memcpy(&r->buf[16], "MSI TARGET      ", 16);
         pstrcpy((char *) &r->buf[32], 4, qemu_hw_version());
     }
     return true;
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index b4782c6..4dae33b 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -2544,7 +2544,7 @@ static void scsi_realize(SCSIDevice *dev, Error **errp)
         s->version = g_strdup(qemu_hw_version());
     }
     if (!s->vendor) {
-        s->vendor = g_strdup("QEMU");
+        s->vendor = g_strdup("Samsung");
     }
     if (s->serial && strlen(s->serial) > MAX_SERIAL_LEN) {
         error_setg(errp, "The serial number can't be longer than %d characters",
@@ -2608,7 +2608,7 @@ static void scsi_hd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.blocksize = s->qdev.conf.logical_block_size;
     s->qdev.type = TYPE_DISK;
     if (!s->product) {
-        s->product = g_strdup("QEMU HARDDISK");
+        s->product = g_strdup("Samsung SSD 980 500GB");
     }
     scsi_realize(&s->qdev, errp);
 }
@@ -2635,7 +2635,7 @@ static void scsi_cd_realize(SCSIDevice *dev, Error **errp)
     s->qdev.type = TYPE_ROM;
     s->features |= 1 << SCSI_DISK_F_REMOVABLE;
     if (!s->product) {
-        s->product = g_strdup("QEMU CD-ROM");
+        s->product = g_strdup("CD-ROM");
     }
     scsi_realize(&s->qdev, errp);
 }
diff --git a/hw/ufs/lu.c b/hw/ufs/lu.c
index 2d8ffd7..e0d2a92 100644
--- a/hw/ufs/lu.c
+++ b/hw/ufs/lu.c
@@ -184,8 +184,8 @@ static int ufs_emulate_wlun_inquiry(UfsRequest *req, uint8_t *outbuf,
     outbuf[5] = 0;
     outbuf[6] = 0;
     outbuf[7] = 0x2;
-    strpadcpy((char *)&outbuf[8], 8, "QEMU", ' ');
-    strpadcpy((char *)&outbuf[16], 16, "QEMU UFS", ' ');
+    strpadcpy((char *)&outbuf[8], 8, "MSI", ' ');
+    strpadcpy((char *)&outbuf[16], 16, "UFS", ' ');
     memset(&outbuf[32], 0, 4);
 
     return SCSI_INQUIRY_LEN;
diff --git a/hw/usb/canokey.c b/hw/usb/canokey.c
index cbefbb5..4b98e7a 100644
--- a/hw/usb/canokey.c
+++ b/hw/usb/canokey.c
@@ -35,8 +35,8 @@ enum {
 
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER]     = "canokeys.org",
-    [STR_PRODUCT]          = "CanoKey QEMU",
-    [STR_SERIALNUMBER]     = "0"
+    [STR_PRODUCT]          = "CanoKey",
+    [STR_SERIALNUMBER]     = ""
 };
 
 static const USBDescDevice desc_device_canokey = {
diff --git a/hw/usb/dev-audio.c b/hw/usb/dev-audio.c
index 8dd9d26..30c4540 100644
--- a/hw/usb/dev-audio.c
+++ b/hw/usb/dev-audio.c
@@ -73,9 +73,9 @@ enum usb_audio_strings {
 };
 
 static const USBDescStrings usb_audio_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "QEMU USB Audio",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Logitech",
+    [STRING_PRODUCT]            = "USB Audio",
+    [STRING_SERIALNUMBER]       = "",
     [STRING_CONFIG]             = "Audio Configuration",
     [STRING_USBAUDIO_CONTROL]   = "Audio Device",
     [STRING_INPUT_TERMINAL]     = "Audio Output Pipe",
diff --git a/hw/usb/dev-hid.c b/hw/usb/dev-hid.c
index 96623aa..218c651 100644
--- a/hw/usb/dev-hid.c
+++ b/hw/usb/dev-hid.c
@@ -63,17 +63,17 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
-    [STR_PRODUCT_MOUSE]    = "QEMU USB Mouse",
-    [STR_PRODUCT_TABLET]   = "QEMU USB Tablet",
-    [STR_PRODUCT_KEYBOARD] = "QEMU USB Keyboard",
-    [STR_SERIAL_COMPAT]    = "42",
+    [STR_MANUFACTURER]     = "Logitech",
+    [STR_PRODUCT_MOUSE]    = "USB Mouse",
+    [STR_PRODUCT_TABLET]   = "USB Tablet",
+    [STR_PRODUCT_KEYBOARD] = "USB Keyboard",
+    [STR_SERIAL_COMPAT]    = "",
     [STR_CONFIG_MOUSE]     = "HID Mouse",
     [STR_CONFIG_TABLET]    = "HID Tablet",
     [STR_CONFIG_KEYBOARD]  = "HID Keyboard",
-    [STR_SERIAL_MOUSE]     = "89126",
-    [STR_SERIAL_TABLET]    = "28754",
-    [STR_SERIAL_KEYBOARD]  = "68284",
+    [STR_SERIAL_MOUSE]     = "",
+    [STR_SERIAL_TABLET]    = "",
+    [STR_SERIAL_KEYBOARD]  = "",
 };
 
 static const USBDescIface desc_iface_mouse = {
@@ -368,8 +368,8 @@ static const USBDescMSOS desc_msos_suspend = {
 
 static const USBDesc desc_mouse = {
     .id = {
-        .idVendor          = 0x0627,
-        .idProduct         = 0x0001,
+        .idVendor          = 0x046D,
+        .idProduct         = 0xC077,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
         .iProduct          = STR_PRODUCT_MOUSE,
@@ -382,8 +382,8 @@ static const USBDesc desc_mouse = {
 
 static const USBDesc desc_mouse2 = {
     .id = {
-        .idVendor          = 0x0627,
-        .idProduct         = 0x0001,
+        .idVendor          = 0x046D,
+        .idProduct         = 0xC077,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
         .iProduct          = STR_PRODUCT_MOUSE,
@@ -426,8 +426,8 @@ static const USBDesc desc_tablet2 = {
 
 static const USBDesc desc_keyboard = {
     .id = {
-        .idVendor          = 0x0627,
-        .idProduct         = 0x0001,
+        .idVendor          = 0x046D,
+        .idProduct         = 0xC31C,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
         .iProduct          = STR_PRODUCT_KEYBOARD,
@@ -440,8 +440,8 @@ static const USBDesc desc_keyboard = {
 
 static const USBDesc desc_keyboard2 = {
     .id = {
-        .idVendor          = 0x0627,
-        .idProduct         = 0x0001,
+        .idVendor          = 0x046D,
+        .idProduct         = 0xC31C,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
         .iProduct          = STR_PRODUCT_KEYBOARD,
@@ -805,7 +805,7 @@ static void usb_tablet_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_tablet_realize;
-    uc->product_desc   = "QEMU USB Tablet";
+    uc->product_desc   = "USB Tablet";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_tablet_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -827,7 +827,7 @@ static void usb_mouse_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mouse_realize;
-    uc->product_desc   = "QEMU USB Mouse";
+    uc->product_desc   = "USB Mouse";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_mouse_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -850,7 +850,7 @@ static void usb_keyboard_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_keyboard_realize;
-    uc->product_desc   = "QEMU USB Keyboard";
+    uc->product_desc   = "USB Keyboard";
     dc->vmsd = &vmstate_usb_kbd;
     device_class_set_props(dc, usb_keyboard_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
diff --git a/hw/usb/dev-hub.c b/hw/usb/dev-hub.c
index a19350d..cdf3008 100644
--- a/hw/usb/dev-hub.c
+++ b/hw/usb/dev-hub.c
@@ -104,9 +104,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB Hub",
-    [STR_SERIALNUMBER] = "314159",
+    [STR_MANUFACTURER] = "Logitech",
+    [STR_PRODUCT]      = "USB Hub",
+    [STR_SERIALNUMBER] = "",
 };
 
 static const USBDescIface desc_iface_hub = {
@@ -676,7 +676,7 @@ static void usb_hub_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_hub_realize;
-    uc->product_desc   = "QEMU USB Hub";
+    uc->product_desc   = "USB Hub";
     uc->usb_desc       = &desc_hub;
     uc->find_device    = usb_hub_find_device;
     uc->handle_reset   = usb_hub_handle_reset;
diff --git a/hw/usb/dev-mtp.c b/hw/usb/dev-mtp.c
index afd7944..cd725e3 100644
--- a/hw/usb/dev-mtp.c
+++ b/hw/usb/dev-mtp.c
@@ -246,8 +246,8 @@ typedef struct {
 
 /* ----------------------------------------------------------------------- */
 
-#define MTP_MANUFACTURER  "QEMU"
-#define MTP_PRODUCT       "QEMU filesharing"
+#define MTP_MANUFACTURER  "Microsoft"
+#define MTP_PRODUCT       "filesharing"
 #define MTP_WRITE_BUF_SZ  (512 * KiB)
 
 enum {
@@ -263,7 +263,7 @@ enum {
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER] = MTP_MANUFACTURER,
     [STR_PRODUCT]      = MTP_PRODUCT,
-    [STR_SERIALNUMBER] = "34617",
+    [STR_SERIALNUMBER] = "",
     [STR_MTP]          = "MTP",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
@@ -2087,7 +2087,7 @@ static void usb_mtp_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_mtp_realize;
-    uc->product_desc   = "QEMU USB MTP";
+    uc->product_desc   = "USB MTP";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_mtp_cancel_packet;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-network.c b/hw/usb/dev-network.c
index 1df2454..a502069 100644
--- a/hw/usb/dev-network.c
+++ b/hw/usb/dev-network.c
@@ -99,16 +99,16 @@ enum usbstring_idx {
 #define ETH_FRAME_LEN                   1514 /* Max. octets in frame sans FCS */
 
 static const USBDescStrings usb_net_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "RNDIS/QEMU USB Network Device",
-    [STRING_ETHADDR]            = "400102030405",
-    [STRING_DATA]               = "QEMU USB Net Data Interface",
-    [STRING_CONTROL]            = "QEMU USB Net Control Interface",
-    [STRING_RNDIS_CONTROL]      = "QEMU USB Net RNDIS Control Interface",
-    [STRING_CDC]                = "QEMU USB Net CDC",
-    [STRING_SUBSET]             = "QEMU USB Net Subset",
-    [STRING_RNDIS]              = "QEMU USB Net RNDIS",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Realtek",
+    [STRING_PRODUCT]            = "RNDIS/Realtek USB Network Device",
+    [STRING_ETHADDR]            = "8A81AB4C9DCE",
+    [STRING_DATA]               = "USB Net Data Interface",
+    [STRING_CONTROL]            = "USB Net Control Interface",
+    [STRING_RNDIS_CONTROL]      = "USB Net RNDIS Control Interface",
+    [STRING_CDC]                = "USB Net CDC",
+    [STRING_SUBSET]             = "USB Net Subset",
+    [STRING_RNDIS]              = "USB Net RNDIS",
+    [STRING_SERIALNUMBER]       = "",
 };
 
 static const USBDescIface desc_iface_rndis[] = {
@@ -717,7 +717,7 @@ static int ndis_query(USBNetState *s, uint32_t oid,
 
     /* mandatory */
     case OID_GEN_VENDOR_DESCRIPTION:
-        pstrcpy((char *)outbuf, outlen, "QEMU USB RNDIS Net");
+        pstrcpy((char *)outbuf, outlen, "USB RNDIS Net");
         return strlen((char *)outbuf) + 1;
 
     case OID_GEN_VENDOR_DRIVER_VERSION:
@@ -1417,7 +1417,7 @@ static void usb_net_class_initfn(ObjectClass *klass, const void *data)
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
     uc->realize        = usb_net_realize;
-    uc->product_desc   = "QEMU USB Network Interface";
+    uc->product_desc   = "USB Network Interface";
     uc->usb_desc       = &desc_net;
     uc->handle_reset   = usb_net_handle_reset;
     uc->handle_control = usb_net_handle_control;
diff --git a/hw/usb/dev-serial.c b/hw/usb/dev-serial.c
index 2eb52b2..57a7fdf 100644
--- a/hw/usb/dev-serial.c
+++ b/hw/usb/dev-serial.c
@@ -119,10 +119,10 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]    = "QEMU",
-    [STR_PRODUCT_SERIAL]  = "QEMU USB SERIAL",
-    [STR_PRODUCT_BRAILLE] = "QEMU USB BAUM BRAILLE",
-    [STR_SERIALNUMBER]    = "1",
+    [STR_MANUFACTURER]    = "Microsoft",
+    [STR_PRODUCT_SERIAL]  = "USB SERIAL",
+    [STR_PRODUCT_BRAILLE] = "USB BAUM BRAILLE",
+    [STR_SERIALNUMBER]    = "",
 };
 
 static const USBDescIface desc_iface0 = {
@@ -663,7 +663,7 @@ static void usb_serial_class_initfn(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Serial";
+    uc->product_desc   = "USB Serial";
     uc->usb_desc       = &desc_serial;
     device_class_set_props(dc, serial_properties);
 }
@@ -683,7 +683,7 @@ static void usb_braille_class_initfn(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB Braille";
+    uc->product_desc   = "USB Braille";
     uc->usb_desc       = &desc_braille;
     device_class_set_props(dc, braille_properties);
 }
diff --git a/hw/usb/dev-smartcard-reader.c b/hw/usb/dev-smartcard-reader.c
index 6ce7154..027a52d 100644
--- a/hw/usb/dev-smartcard-reader.c
+++ b/hw/usb/dev-smartcard-reader.c
@@ -80,10 +80,10 @@ OBJECT_DECLARE_SIMPLE_TYPE(USBCCIDState, USB_CCID_DEV)
 #define CCID_CONTROL_GET_CLOCK_FREQUENCIES  0x2
 #define CCID_CONTROL_GET_DATA_RATES         0x3
 
-#define CCID_PRODUCT_DESCRIPTION        "QEMU USB CCID"
-#define CCID_VENDOR_DESCRIPTION         "QEMU"
+#define CCID_PRODUCT_DESCRIPTION        "USB CCID"
+#define CCID_VENDOR_DESCRIPTION         "Identiv"
 #define CCID_INTERFACE_NAME             "CCID Interface"
-#define CCID_SERIAL_NUMBER_STRING       "1"
+#define CCID_SERIAL_NUMBER_STRING       ""
 /*
  * Using Gemplus Vendor and Product id
  * Effect on various drivers:
@@ -419,9 +419,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]  = "QEMU",
-    [STR_PRODUCT]       = "QEMU USB CCID",
-    [STR_SERIALNUMBER]  = "1",
+    [STR_MANUFACTURER]  = "Identiv",
+    [STR_PRODUCT]       = "USB CCID",
+    [STR_SERIALNUMBER]  = "",
     [STR_INTERFACE]     = "CCID Interface",
 };
 
@@ -1440,7 +1440,7 @@ static void ccid_class_initfn(ObjectClass *klass, const void *data)
     HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(klass);
 
     uc->realize        = ccid_realize;
-    uc->product_desc   = "QEMU USB CCID";
+    uc->product_desc   = "USB CCID";
     uc->usb_desc       = &desc_ccid;
     uc->handle_reset   = ccid_handle_reset;
     uc->handle_control = ccid_handle_control;
diff --git a/hw/usb/dev-storage.c b/hw/usb/dev-storage.c
index b13fe34..a02b0cd 100644
--- a/hw/usb/dev-storage.c
+++ b/hw/usb/dev-storage.c
@@ -47,9 +47,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB HARDDRIVE",
-    [STR_SERIALNUMBER] = "1",
+    [STR_MANUFACTURER] = "Samsung",
+    [STR_PRODUCT]      = "USB HARDDRIVE",
+    [STR_SERIALNUMBER] = "",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
@@ -590,7 +590,7 @@ static void usb_msd_class_initfn_common(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU USB MSD";
+    uc->product_desc   = "USB MSD";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_msd_cancel_io;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-uas.c b/hw/usb/dev-uas.c
index 18ebe15..0048a8f 100644
--- a/hw/usb/dev-uas.c
+++ b/hw/usb/dev-uas.c
@@ -170,9 +170,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
+    [STR_MANUFACTURER] = "Microsoft",
     [STR_PRODUCT]      = "USB Attached SCSI HBA",
-    [STR_SERIALNUMBER] = "27842",
+    [STR_SERIALNUMBER] = "",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
 };
diff --git a/hw/usb/dev-wacom.c b/hw/usb/dev-wacom.c
index f4b71a2..028189f 100644
--- a/hw/usb/dev-wacom.c
+++ b/hw/usb/dev-wacom.c
@@ -64,9 +64,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Wacom",
     [STR_PRODUCT]          = "Wacom PenPartner",
-    [STR_SERIALNUMBER]     = "1",
+    [STR_SERIALNUMBER]     = "",
 };
 
 static const uint8_t qemu_wacom_hid_report_descriptor[] = {
@@ -231,7 +231,7 @@ static int usb_mouse_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_mouse_event, s, 0,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -269,7 +269,7 @@ static int usb_wacom_poll(USBWacomState *s, uint8_t *buf, int len)
 
     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_wacom_event, s, 1,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -425,7 +425,7 @@ static void usb_wacom_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU PenPartner Tablet";
+    uc->product_desc   = "PenPartner Tablet";
     uc->usb_desc       = &desc_wacom;
     uc->realize        = usb_wacom_realize;
     uc->handle_reset   = usb_wacom_handle_reset;
@@ -433,7 +433,7 @@ static void usb_wacom_class_init(ObjectClass *klass, const void *data)
     uc->handle_data    = usb_wacom_handle_data;
     uc->unrealize      = usb_wacom_unrealize;
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
-    dc->desc = "QEMU PenPartner Tablet";
+    dc->desc = "PenPartner Tablet";
     dc->vmsd = &vmstate_usb_wacom;
 }
 
diff --git a/hw/usb/u2f-emulated.c b/hw/usb/u2f-emulated.c
index ace5ece..8cb276a 100644
--- a/hw/usb/u2f-emulated.c
+++ b/hw/usb/u2f-emulated.c
@@ -385,7 +385,7 @@ static void u2f_emulated_class_init(ObjectClass *klass, const void *data)
     kc->realize = u2f_emulated_realize;
     kc->unrealize = u2f_emulated_unrealize;
     kc->recv_from_guest = u2f_emulated_recv_from_guest;
-    dc->desc = "QEMU U2F emulated key";
+    dc->desc = "U2F emulated key";
     device_class_set_props(dc, u2f_emulated_properties);
 }
 
diff --git a/hw/usb/u2f-passthru.c b/hw/usb/u2f-passthru.c
index fa8d9cd..cd4d451 100644
--- a/hw/usb/u2f-passthru.c
+++ b/hw/usb/u2f-passthru.c
@@ -528,7 +528,7 @@ static void u2f_passthru_class_init(ObjectClass *klass, const void *data)
     kc->realize = u2f_passthru_realize;
     kc->unrealize = u2f_passthru_unrealize;
     kc->recv_from_guest = u2f_passthru_recv_from_guest;
-    dc->desc = "QEMU U2F passthrough key";
+    dc->desc = "U2F passthrough key";
     dc->vmsd = &u2f_passthru_vmstate;
     device_class_set_props(dc, u2f_passthru_properties);
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
diff --git a/hw/usb/u2f.c b/hw/usb/u2f.c
index b051a99..ec103ba 100644
--- a/hw/usb/u2f.c
+++ b/hw/usb/u2f.c
@@ -46,9 +46,9 @@ enum {
 };
 
 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Microsoft",
     [STR_PRODUCT]          = "U2F USB key",
-    [STR_SERIALNUMBER]     = "0",
+    [STR_SERIALNUMBER]     = "",
     [STR_CONFIG]           = "U2F key config",
     [STR_INTERFACE]        = "U2F key interface"
 };
@@ -322,7 +322,7 @@ static void u2f_key_class_init(ObjectClass *klass, const void *data)
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);
 
-    uc->product_desc   = "QEMU U2F USB key";
+    uc->product_desc   = "U2F USB key";
     uc->usb_desc       = &desc_u2f_key;
     uc->handle_reset   = u2f_key_handle_reset;
     uc->handle_control = u2f_key_handle_control;
@@ -330,7 +330,7 @@ static void u2f_key_class_init(ObjectClass *klass, const void *data)
     uc->handle_attach  = usb_desc_attach;
     uc->realize        = u2f_key_realize;
     uc->unrealize      = u2f_key_unrealize;
-    dc->desc           = "QEMU U2F key";
+    dc->desc           = "U2F key";
     dc->vmsd           = &vmstate_u2f_key;
 }
 
diff --git a/hw/vfio/ap.c b/hw/vfio/ap.c
index 3368ac8..bcc5c28 100644
--- a/hw/vfio/ap.c
+++ b/hw/vfio/ap.c
@@ -340,7 +340,7 @@ static void vfio_ap_class_init(ObjectClass *klass, const void *data)
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
     dc->realize = vfio_ap_realize;
     dc->unrealize = vfio_ap_unrealize;
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     device_class_set_legacy_reset(dc, vfio_ap_reset);
     dc->bus_type = TYPE_AP_BUS;
 
diff --git a/include/hw/acpi/aml-build.h b/include/hw/acpi/aml-build.h
index f38e129..e346f2d 100644
--- a/include/hw/acpi/aml-build.h
+++ b/include/hw/acpi/aml-build.h
@@ -4,8 +4,8 @@
 #include "hw/acpi/acpi-defs.h"
 #include "hw/acpi/bios-linker-loader.h"
 
-#define ACPI_BUILD_APPNAME6 "BOCHS "
-#define ACPI_BUILD_APPNAME8 "BXPC    "
+#define ACPI_BUILD_APPNAME6 "ALASKA"
+#define ACPI_BUILD_APPNAME8 "A M I   "
 
 #define ACPI_BUILD_TABLE_FILE "etc/acpi/tables"
 #define ACPI_BUILD_RSDP_FILE "etc/acpi/rsdp"
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index b72e484..a15ff52 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -57,12 +57,12 @@ extern bool pci_available;
 #define PCI_DEVICE_ID_MARVELL_GT6412X    0x4620
 
 /* QEMU/Bochs VGA (0x1234) */
-#define PCI_VENDOR_ID_QEMU               0x1234
+#define PCI_VENDOR_ID_QEMU               0x1022 // "???" | AMD Vendor ID Replacement from 0x1234
 #define PCI_DEVICE_ID_QEMU_VGA           0x1111
 #define PCI_DEVICE_ID_QEMU_IPMI          0x1112
 
 /* VMWare (0x15ad) */
-#define PCI_VENDOR_ID_VMWARE             0x15ad
+#define PCI_VENDOR_ID_VMWARE             0x1022 // AMD Vendor ID Replacement from 0x15ad
 #define PCI_DEVICE_ID_VMWARE_SVGA2       0x0405
 #define PCI_DEVICE_ID_VMWARE_SVGA        0x0710
 #define PCI_DEVICE_ID_VMWARE_NET         0x0720
@@ -74,12 +74,12 @@ extern bool pci_available;
 /* Intel (0x8086) */
 #define PCI_DEVICE_ID_INTEL_82551IT      0x1209
 #define PCI_DEVICE_ID_INTEL_82557        0x1229
-#define PCI_DEVICE_ID_INTEL_82801IR      0x2922
+#define PCI_DEVICE_ID_INTEL_82801IR      0x790e // Intel 82801IR ICH9 - LPC Bridge [A2] | AMD Device ID Replacement from 0x2922 | hw/ide/ich.c
 
 /* Red Hat / Qumranet (for QEMU) -- see pci-ids.txt */
-#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1af4
-#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1af4
-#define PCI_SUBDEVICE_ID_QEMU            0x1100
+#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1022 // AMD Vendor ID Replacement from 0x1af4
+#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1022 // AMD Subvendor ID Replacement from 0x1af4
+#define PCI_SUBDEVICE_ID_QEMU            0x1022 // AMD Subdevice ID Replacement from 0x1100
 
 /* legacy virtio-pci devices */
 #define PCI_DEVICE_ID_VIRTIO_NET         0x1000
@@ -100,21 +100,21 @@ extern bool pci_available;
  */
 #define PCI_DEVICE_ID_VIRTIO_10_BASE     0x1040
 
-#define PCI_VENDOR_ID_REDHAT             0x1b36
-#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x0001
-#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002
+#define PCI_VENDOR_ID_REDHAT             0x1022 // "Red Hat, Inc." | AMD Vendor ID Replacement from 0x1b36
+#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x57a3 // "QEMU PCI-PCI bridge" | AMD Device ID Replacement from 0x0001 | hw/pci-bridge/pci_bridge_dev.c
+#define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002 // TODO: find device_id | AMD Device ID Replacement from 0x???? | hw/char/serial-pci.c
 #define PCI_DEVICE_ID_REDHAT_SERIAL2     0x0003
 #define PCI_DEVICE_ID_REDHAT_SERIAL4     0x0004
 #define PCI_DEVICE_ID_REDHAT_TEST        0x0005
 #define PCI_DEVICE_ID_REDHAT_ROCKER      0x0006
 #define PCI_DEVICE_ID_REDHAT_SDHCI       0x0007
-#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x0008
+#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x1482 // "QEMU PCIe Host bridge" | AMD Device ID Replacement from 0x0008 | hw/pci-host/gpex.c
 #define PCI_DEVICE_ID_REDHAT_PXB         0x0009
 #define PCI_DEVICE_ID_REDHAT_BRIDGE_SEAT 0x000a
 #define PCI_DEVICE_ID_REDHAT_PXB_PCIE    0x000b
-#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x000c
-#define PCI_DEVICE_ID_REDHAT_XHCI        0x000d
-#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x000e
+#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x1483 // "QEMU PCIe Root Port" | AMD Device ID Replacement from 0x000c | hw/pci-bridge/gen_pcie_root_port.c
+#define PCI_DEVICE_ID_REDHAT_XHCI        0x149c // "QEMU XHCI Host Controller" | AMD Device ID Replacement from 0x000d | hw/usb/hcd-xhci-pci.c
+#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x57ad // "Red Hat, Device ID: 000E" | AMD Device ID Replacement from 0x000e | hw/pci-bridge/pcie_pci_bridge.c
 #define PCI_DEVICE_ID_REDHAT_MDPY        0x000f
 #define PCI_DEVICE_ID_REDHAT_NVME        0x0010
 #define PCI_DEVICE_ID_REDHAT_PVPANIC     0x0011
diff --git a/include/hw/pci/pci_ids.h b/include/hw/pci/pci_ids.h
index 16034aa..2bae16e 100644
--- a/include/hw/pci/pci_ids.h
+++ b/include/hw/pci/pci_ids.h
@@ -178,6 +178,7 @@
 #define PCI_VENDOR_ID_AMD                0x1022
 #define PCI_DEVICE_ID_AMD_LANCE          0x2000
 #define PCI_DEVICE_ID_AMD_SCSI           0x2020
+#define PCI_DEVICE_ID_AMD_SATA           0x7900 // FCH SATA Controller [IDE mode] | hw/ide/ich.c
 
 #define PCI_VENDOR_ID_HP                 0x103c
 
@@ -241,7 +242,7 @@
 #define PCI_DEVICE_ID_INTEL_82378        0x0484
 #define PCI_DEVICE_ID_INTEL_82441        0x1237
 #define PCI_DEVICE_ID_INTEL_82801AA_5    0x2415
-#define PCI_DEVICE_ID_INTEL_82801BA_11   0x244e
+#define PCI_DEVICE_ID_INTEL_82801BA_11   0x14db // Type: Bridge Device | Category: PCI-to-PCI Bridge | PCI Class: 0x0604 | hw/pci-bridge/i82801b11.c
 #define PCI_DEVICE_ID_INTEL_82801D       0x24CD
 #define PCI_DEVICE_ID_INTEL_ESB_9        0x25ab
 #define PCI_DEVICE_ID_INTEL_NVME         0x5845
@@ -259,9 +260,9 @@
 #define PCI_DEVICE_ID_INTEL_ICH9_3       0x2913
 #define PCI_DEVICE_ID_INTEL_ICH9_4       0x2914
 #define PCI_DEVICE_ID_INTEL_ICH9_5       0x2919
-#define PCI_DEVICE_ID_INTEL_ICH9_6       0x2930
+#define PCI_DEVICE_ID_INTEL_ICH9_6       0x790b // Type: System Device | Category: SMBus Controller | PCI Class: 0x0c05 | hw/i2c/smbus_ich9.c
 #define PCI_DEVICE_ID_INTEL_ICH9_7       0x2916
-#define PCI_DEVICE_ID_INTEL_ICH9_8       0x2918
+#define PCI_DEVICE_ID_INTEL_ICH9_8       0x790e // Type: Bridge Device | Category: LPC Controller   | PCI Class: 0x0601 | hw/isa/lpc_ich9.c
 
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI1 0x2934
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI2 0x2935
@@ -273,7 +274,7 @@
 #define PCI_DEVICE_ID_INTEL_82801I_EHCI2 0x293c
 #define PCI_DEVICE_ID_INTEL_82599_SFP_VF 0x10ed
 
-#define PCI_DEVICE_ID_INTEL_P35_MCH      0x29c0
+#define PCI_DEVICE_ID_INTEL_P35_MCH      0x14d8 // Type: Bridge Device | Category: Host Bridge | PCI Class: 0x0600 | hw/pci-host/q35.c
 
 #define PCI_VENDOR_ID_XEN                0x5853
 #define PCI_DEVICE_ID_XEN_PLATFORM       0x0001
diff --git a/include/standard-headers/linux/qemu_fw_cfg.h b/include/standard-headers/linux/qemu_fw_cfg.h
index cb93f66..fe34590 100644
--- a/include/standard-headers/linux/qemu_fw_cfg.h
+++ b/include/standard-headers/linux/qemu_fw_cfg.h
@@ -4,7 +4,7 @@
 
 #include "standard-headers/linux/types.h"
 
-#define FW_CFG_ACPI_DEVICE_ID	"QEMU0002"
+#define FW_CFG_ACPI_DEVICE_ID	"UEFI0002"
 
 /* selector key values for "well-known" fw_cfg entries */
 #define FW_CFG_SIGNATURE	0x00
@@ -71,7 +71,7 @@ struct fw_cfg_file {
 #define FW_CFG_DMA_CTL_SELECT	0x08
 #define FW_CFG_DMA_CTL_WRITE	0x10
 
-#define FW_CFG_DMA_SIGNATURE    0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE    0x51434f4d20434647ULL /* "QCOM CFG" */
 
 /* Control as first field allows for different structures selected by this
  * field, which might be useful in the future
diff --git a/pc-bios/optionrom/optionrom.h b/pc-bios/optionrom/optionrom.h
index 7bcdf0e..02dd06e 100644
--- a/pc-bios/optionrom/optionrom.h
+++ b/pc-bios/optionrom/optionrom.h
@@ -43,7 +43,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10
 
-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */
 
 #define BIOS_CFG_DMA_ADDR_HIGH  0x514
 #define BIOS_CFG_DMA_ADDR_LOW   0x518
diff --git a/pc-bios/s390-ccw/virtio-scsi.h b/pc-bios/s390-ccw/virtio-scsi.h
index c5612e1..048cb93 100644
--- a/pc-bios/s390-ccw/virtio-scsi.h
+++ b/pc-bios/s390-ccw/virtio-scsi.h
@@ -25,7 +25,7 @@
 #define VIRTIO_SCSI_S_OK                     0x00
 #define VIRTIO_SCSI_S_BAD_TARGET             0x03
 
-#define QEMU_CDROM_SIGNATURE "QEMU CD-ROM     "
+#define QEMU_CDROM_SIGNATURE "ASUS CD-ROM     "
 
 enum virtio_scsi_vq_id {
     VR_CONTROL  = 0,
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 6417775..ecb3184 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -10019,8 +10019,8 @@ static const Property x86_cpu_properties[] = {
     DEFINE_PROP_BOOL("lmce", X86CPU, enable_lmce, false),
     DEFINE_PROP_BOOL("l3-cache", X86CPU, enable_l3_cache, true),
     DEFINE_PROP_BOOL("kvm-pv-enforce-cpuid", X86CPU, kvm_pv_enforce_cpuid,
-                     false),
-    DEFINE_PROP_BOOL("vmware-cpuid-freq", X86CPU, vmware_cpuid_freq, true),
+                     true),
+    DEFINE_PROP_BOOL("vmware-cpuid-freq", X86CPU, vmware_cpuid_freq, false),
     DEFINE_PROP_BOOL("tcg-cpuid", X86CPU, expose_tcg, true),
     DEFINE_PROP_BOOL("x-migrate-smi-count", X86CPU, migrate_smi_count,
                      true),
diff --git a/target/i386/kvm/kvm-cpu.c b/target/i386/kvm/kvm-cpu.c
index 9c25b55..1ae774b 100644
--- a/target/i386/kvm/kvm-cpu.c
+++ b/target/i386/kvm/kvm-cpu.c
@@ -174,17 +174,6 @@ static void kvm_cpu_xsave_init(void)
  *       docs/system/target-i386.rst)
  */
 static PropValue kvm_default_props[] = {
-    { "kvmclock", "on" },
-    { "kvm-nopiodelay", "on" },
-    { "kvm-asyncpf", "on" },
-    { "kvm-steal-time", "on" },
-    { "kvm-pv-eoi", "on" },
-    { "kvmclock-stable-bit", "on" },
-    { "x2apic", "on" },
-    { "kvm-msi-ext-dest-id", "off" },
-    { "acpi", "off" },
-    { "monitor", "off" },
-    { "svm", "off" },
     { NULL, NULL },
 };
 
@@ -216,13 +205,6 @@ static void kvm_cpu_instance_init(CPUState *cs)
     host_cpu_instance_init(cpu);
 
     if (xcc->model) {
-        /* only applies to builtin_x86_defs cpus */
-        if (!kvm_irqchip_in_kernel()) {
-            x86_cpu_change_kvm_default("x2apic", "off");
-        } else if (kvm_irqchip_is_split()) {
-            x86_cpu_change_kvm_default("kvm-msi-ext-dest-id", "on");
-        }
-
         /* Special cases not set in the X86CPUDefinition structs: */
         x86_cpu_apply_props(cpu, kvm_default_props);
     }

diff --git a/block/vhdx.c b/block/vhdx.c
--- a/block/vhdx.c
+++ b/block/vhdx.c
@@ -2020,7 +2020,7 @@

     /* The creator field is optional, but may be useful for
      * debugging / diagnostics */
-    creator = g_utf8_to_utf16("QEMU v" QEMU_VERSION, -1, NULL,
+    creator = g_utf8_to_utf16("Microsoft v" QEMU_VERSION, -1, NULL,
                               &creator_items, NULL);
     signature = cpu_to_le64(VHDX_FILE_SIGNATURE);
     ret = blk_co_pwrite(blk, VHDX_FILE_ID_OFFSET, sizeof(signature), &signature,
diff --git a/block/vvfat.c b/block/vvfat.c
--- a/block/vvfat.c
+++ b/block/vvfat.c
@@ -1176,7 +1176,7 @@
         }
         memcpy(s->volume_label, label, label_length);
     } else {
-        memcpy(s->volume_label, "QEMU VVFAT", 10);
+        memcpy(s->volume_label, "VVFAT", 5);
     }

     if (floppy) {
diff --git a/chardev/msmouse.c b/chardev/msmouse.c
--- a/chardev/msmouse.c
+++ b/chardev/msmouse.c
@@ -172,7 +172,7 @@
 }

 static const QemuInputHandler msmouse_handler = {
-    .name  = "QEMU Microsoft Mouse",
+    .name  = "Microsoft Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = msmouse_input_event,
     .sync  = msmouse_input_sync,
diff --git a/chardev/wctablet.c b/chardev/wctablet.c
--- a/chardev/wctablet.c
+++ b/chardev/wctablet.c
@@ -179,7 +179,7 @@
 }

 static const QemuInputHandler wctablet_handler = {
-    .name  = "QEMU Wacom Pen Tablet",
+    .name  = "Wacom Pen Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = wctablet_input_event,
     .sync  = wctablet_input_sync,
diff --git a/contrib/vhost-user-gpu/vhost-user-gpu.c b/contrib/vhost-user-gpu/vhost-user-gpu.c
--- a/contrib/vhost-user-gpu/vhost-user-gpu.c
+++ b/contrib/vhost-user-gpu/vhost-user-gpu.c
@@ -1254,7 +1254,7 @@
     QTAILQ_INIT(&g.reslist);
     QTAILQ_INIT(&g.fenceq);

-    context = g_option_context_new("QEMU vhost-user-gpu");
+    context = g_option_context_new("vhost-user-gpu");
     g_option_context_add_main_entries(context, entries, NULL);
     if (!g_option_context_parse(context, &argc, &argv, &error)) {
         g_printerr("Option parsing failed: %s\n", error->message);
diff --git a/hw/acpi/aml-build.c b/hw/acpi/aml-build.c
--- a/hw/acpi/aml-build.c
+++ b/hw/acpi/aml-build.c
@@ -1723,11 +1723,11 @@
     build_append_int_noprefix(array, 0, 4); /* Length */
     build_append_int_noprefix(array, desc->rev, 1); /* Revision */
     build_append_int_noprefix(array, 0, 1); /* Checksum */
-    build_append_padded_str(array, desc->oem_id, 6, '\0'); /* OEMID */
+    build_append_padded_str(array, ACPI_BUILD_APPNAME6, 6, '\0'); /* OEMID */
     /* OEM Table ID */
-    build_append_padded_str(array, desc->oem_table_id, 8, '\0');
+    build_append_padded_str(array, ACPI_BUILD_APPNAME8, 8, '\0');
     build_append_int_noprefix(array, 1, 4); /* OEM Revision */
-    g_array_append_vals(array, ACPI_BUILD_APPNAME8, 4); /* Creator ID */
+    g_array_append_vals(array, "    ", 4); /* Creator ID */
     build_append_int_noprefix(array, 1, 4); /* Creator Revision */
 }

@@ -2248,7 +2248,7 @@
     /* ACPI1.0: INT_MODEL, ACPI2.0+: Reserved */
     build_append_int_noprefix(tbl, f->int_model /* Multiple APIC */, 1);
     /* Preferred_PM_Profile */
-    build_append_int_noprefix(tbl, 0 /* Unspecified */, 1);
+    build_append_int_noprefix(tbl, 0 /* Unspecified */, 1);
     build_append_int_noprefix(tbl, f->sci_int, 2); /* SCI_INT */
     build_append_int_noprefix(tbl, f->smi_cmd, 4); /* SMI_CMD */
     build_append_int_noprefix(tbl, f->acpi_enable_cmd, 1); /* ACPI_ENABLE */
@@ -2345,7 +2345,7 @@
     }

     /* Hypervisor Vendor Identity */
-    build_append_padded_str(tbl, "QEMU", 8, '\0');
+    build_append_padded_str(tbl, "", 8, '\0');

     /* TODO: extra fields need to be added to support revisions above rev6 */
     assert(f->rev == 6);
diff --git a/hw/arm/sbsa-ref.c b/hw/arm/sbsa-ref.c
--- a/hw/arm/sbsa-ref.c
+++ b/hw/arm/sbsa-ref.c
@@ -894,7 +894,7 @@
     };

     mc->init = sbsa_ref_init;
-    mc->desc = "QEMU 'SBSA Reference' ARM Virtual Machine";
+    mc->desc = "Qualcomm 'Reference' ARM SoC";
     mc->default_cpu_type = ARM_CPU_TYPE_NAME("neoverse-n2");
     mc->valid_cpu_types = valid_cpu_types;
     mc->max_cpus = 512;
diff --git a/hw/arm/virt.c b/hw/arm/virt.c
--- a/hw/arm/virt.c
+++ b/hw/arm/virt.c
@@ -112,7 +112,7 @@
         MachineClass *mc = MACHINE_CLASS(oc); \
         arm_virt_compat_set(mc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " ARM Virtual Machine"; \
+        mc->desc = "QCOM  " MACHINE_VER_STR(__VA_ARGS__) " ARM Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
@@ -1708,13 +1708,13 @@
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
     struct smbios_phys_mem_area mem_array;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "QCOM Machine";

     if (kvm_enabled()) {
-        product = "KVM Virtual Machine";
+        product = "QCOM Machine";
     }

-    smbios_set_defaults("QEMU", product,
+    smbios_set_defaults("Unknown", product,
                         vmc->smbios_old_sys_ver ? "1.0" : mc->name);

     /* build the array of physical mem area from base_memmap */
diff --git a/hw/char/escc.c b/hw/char/escc.c
--- a/hw/char/escc.c
+++ b/hw/char/escc.c
@@ -1037,7 +1037,7 @@
 }

 static const QemuInputHandler sunmouse_handler = {
-    .name  = "QEMU Sun Mouse",
+    .name  = "Sun Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = sunmouse_handle_event,
     .sync  = sunmouse_sync,
diff --git a/hw/char/serial-pci.c b/hw/char/serial-pci.c
--- a/hw/char/serial-pci.c
+++ b/hw/char/serial-pci.c
@@ -92,8 +92,8 @@
     pc->realize = serial_pci_realize;
     pc->exit = serial_pci_exit;
     pc->vendor_id = PCI_VENDOR_ID_REDHAT;
-    pc->device_id = PCI_DEVICE_ID_REDHAT_SERIAL;
-    pc->revision = 1;
+    pc->device_id = PCI_DEVICE_ID_REDHAT_SERIAL; // Use host Device ID and override it here
+    pc->revision = 1; // Use host Revision ID and override it here
     pc->class_id = PCI_CLASS_COMMUNICATION_SERIAL;
     dc->vmsd = &vmstate_pci_serial;
     device_class_set_props(dc, serial_pci_properties);
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -745,7 +745,7 @@
      * hotpluggable. Devices that shouldn't be hotpluggable,
      * should override it in their class_init()
      */
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     dc->user_creatable = true;
     vc->get_id = device_vmstate_if_get_id;
     rc->get_state = device_get_reset_state;
diff --git a/hw/display/edid-generate.c b/hw/display/edid-generate.c
--- a/hw/display/edid-generate.c
+++ b/hw/display/edid-generate.c
@@ -388,22 +388,22 @@
     uint8_t *did = NULL;
     uint32_t width_mm, height_mm;
     uint32_t refresh_rate = info->refresh_rate ? info->refresh_rate : 75000;
-    uint32_t dpi = 100; /* if no width_mm/height_mm */
+    uint32_t dpi = 82; /* if no width_mm/height_mm */
     uint32_t large_screen = 0;

     /* =============== set defaults  =============== */

     if (!info->vendor || strlen(info->vendor) != 3) {
-        info->vendor = "RHT";
+        info->vendor = "MSI";
     }
     if (!info->name) {
-        info->name = "QEMU Monitor";
+        info->name = "G27C4X";
     }
     if (!info->prefx) {
-        info->prefx = 1280;
+        info->prefx = 1920;
     }
     if (!info->prefy) {
-        info->prefy = 800;
+        info->prefy = 1080;
     }
     if (info->width_mm && info->height_mm) {
         width_mm = info->width_mm;
@@ -449,15 +449,15 @@
     uint16_t vendor_id = ((((info->vendor[0] - '@') & 0x1f) << 10) |
                           (((info->vendor[1] - '@') & 0x1f) <<  5) |
                           (((info->vendor[2] - '@') & 0x1f) <<  0));
-    uint16_t model_nr = 0x1234;
+    uint16_t model_nr = 0x10ad;
     uint32_t serial_nr = info->serial ? atoi(info->serial) : 0;
     stw_be_p(edid +  8, vendor_id);
     stw_le_p(edid + 10, model_nr);
     stl_le_p(edid + 12, serial_nr);

     /* manufacture week and year */
-    edid[16] = 42;
-    edid[17] = 2014 - 1990;
+    edid[16] = 12;
+    edid[17] = 2025 - 2018;

     /* edid version */
     edid[18] = 1;
diff --git a/hw/display/qxl.c b/hw/display/qxl.c
--- a/hw/display/qxl.c
+++ b/hw/display/qxl.c
@@ -2503,7 +2503,7 @@
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

-    k->vendor_id = REDHAT_PCI_VENDOR_ID;
+    k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = QXL_DEVICE_ID_STABLE;
     set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
     device_class_set_legacy_reset(dc, qxl_reset_handler);
diff --git a/hw/i2c/smbus_ich9.c b/hw/i2c/smbus_ich9.c
--- a/hw/i2c/smbus_ich9.c
+++ b/hw/i2c/smbus_ich9.c
@@ -124,12 +124,12 @@
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
     AcpiDevAmlIfClass *adevc = ACPI_DEV_AML_IF_CLASS(klass);

-    k->vendor_id = PCI_VENDOR_ID_INTEL;
-    k->device_id = PCI_DEVICE_ID_INTEL_ICH9_6;
-    k->revision = ICH9_A2_SMB_REVISION;
+    k->vendor_id = PCI_VENDOR_ID_AMD;
+    k->device_id = PCI_DEVICE_ID_AMD_FCH_SMBUS_CONTROLLER;
+    k->revision = AMD_ICH9Emu_A2_SMB_REVISION;
     k->class_id = PCI_CLASS_SERIAL_SMBUS;
     dc->vmsd = &vmstate_ich9_smbus;
-    dc->desc = "ICH9 SMBUS Bridge";
+    dc->desc = "AMD SMBUS Bridge";
     k->realize = ich9_smbus_realize;
     k->config_write = ich9_smbus_write_config;
     /*
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -2588,9 +2588,6 @@
                        x86ms->oem_id, x86ms->oem_table_id, &pcms->cxl_devices_state);
     }

-    acpi_add_table(table_offsets, tables_blob);
-    build_waet(tables_blob, tables->linker, x86ms->oem_id, x86ms->oem_table_id);
-
     /* Add tables supplied by user (if any) */
     for (u = acpi_table_first(); u; u = acpi_table_next(u)) {
         unsigned len = acpi_table_len(u);
@@ -2599,6 +2596,14 @@
         g_array_append_vals(tables_blob, u, len);
     }

+    // /* Disable BGRT (UEFI Logo) */
+    // acpi_add_table(table_offsets, tables_blob);
+    // AcpiTable table = { .sig = "BGRT", .rev = 1,
+    //                     .oem_id = x86ms->oem_id, .oem_table_id = x86ms->oem_table_id };
+    // acpi_table_begin(&table, tables_blob);
+    // build_append_int_noprefix(tables_blob,0x00000000,4);
+    // acpi_table_end(tables->linker, &table);
+
     /* RSDT is pointed to by RSDP */
     rsdt = tables_blob->len;
     build_rsdt(tables_blob, tables->linker, table_offsets,
diff --git a/hw/i386/fw_cfg.c b/hw/i386/fw_cfg.c
--- a/hw/i386/fw_cfg.c
+++ b/hw/i386/fw_cfg.c
@@ -75,7 +75,7 @@

     if (pcmc->smbios_defaults) {
         /* These values are guest ABI, do not change */
-        smbios_set_defaults("QEMU", mc->desc, mc->name);
+        smbios_set_defaults("Advanced Micro Devices, Inc.", mc->desc, mc->name);
     }

     /* tell smbios about cpuid version and features */
@@ -212,6 +212,14 @@
     fw_cfg_add_file(fw_cfg, "etc/msr_feature_control", val, sizeof(*val));
 }

+/*
+ *
+ * TODO: In the future we might need to disable this entire function from being used.
+ * Would need to disable this function from being called in two other files also:
+ * "hw/i386/acpi-microvm.c" and "hw/i386/acpi-build.c"
+ *
+ */
+
 #ifdef CONFIG_ACPI
 void fw_cfg_add_acpi_dsdt(Aml *scope, FWCfgState *fw_cfg)
 {
@@ -225,10 +233,10 @@
     uint8_t io_size = object_property_get_bool(obj, "dma_enabled", NULL) ?
         ROUND_UP(FW_CFG_CTL_SIZE, 4) + sizeof(dma_addr_t) :
         FW_CFG_CTL_SIZE;
-    Aml *dev = aml_device("FWCF");
+    Aml *dev = aml_device("FWCG");
     Aml *crs = aml_resource_template();

-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0002")));

     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
diff --git a/hw/i386/multiboot.c b/hw/i386/multiboot.c
--- a/hw/i386/multiboot.c
+++ b/hw/i386/multiboot.c
@@ -102,7 +102,7 @@
     int mb_mods_count;
 } MultibootState;

-const char *bootloader_name = "qemu";
+const char *bootloader_name = "Windows Boot Manager";

 static uint32_t mb_add_cmdline(MultibootState *s, const char *cmdline)
 {
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -75,9 +75,9 @@
  * depending on QEMU versions up to QEMU 2.4.
  */
 #define PC_CPU_MODEL_IDS(v) \
-    { "qemu32-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "qemu64-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },\
-    { "athlon-" TYPE_X86_CPU, "model-id", "QEMU Virtual CPU version " v, },
+    { "qemu32-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "qemu64-" TYPE_X86_CPU, "model-id", "CPU version " v, },\
+    { "athlon-" TYPE_X86_CPU, "model-id", "CPU version " v, },

 GlobalProperty pc_compat_9_2[] = {};
 const size_t pc_compat_9_2_len = G_N_ELEMENTS(pc_compat_9_2);
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -342,8 +342,8 @@
     pcmc->pci_root_uid = 0;
     pcmc->default_cpu_version = 1;

-    m->family = "pc_q35";
-    m->desc = "Standard PC (Q35 + ICH9, 2009)";
+    m->family = "pc_x570";
+    m->desc = "AMD Ryzen 7 7700X 8-Core Processor";
     m->units_per_default_bus = 1;
     m->default_machine_opts = "firmware=bios-256k.bin";
     m->default_display = "std";
diff --git a/hw/ide/atapi.c b/hw/ide/atapi.c
--- a/hw/ide/atapi.c
+++ b/hw/ide/atapi.c
@@ -798,8 +798,8 @@
         buf[5] = 0;    /* reserved */
         buf[6] = 0;    /* reserved */
         buf[7] = 0;    /* reserved */
-        padstr8(buf + 8, 8, "QEMU");
-        padstr8(buf + 16, 16, "QEMU DVD-ROM");
+        padstr8(buf + 8, 8, "Samsung");
+        padstr8(buf + 16, 16, "DVD-ROM");
         padstr8(buf + 32, 4, s->version);
         idx = 36;
     }
diff --git a/hw/ide/core.c b/hw/ide/core.c
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -2639,20 +2639,20 @@
         pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), dev->serial);
     } else {
         snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),
-                 "QM%05d", s->drive_serial);
+                 "IH9GSSLW0FFNFYB%05d", s->drive_serial);
     }
     if (dev->model) {
         pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), dev->model);
     } else {
         switch (kind) {
         case IDE_CD:
-            strcpy(s->drive_model_str, "QEMU DVD-ROM");
+            strcpy(s->drive_model_str, "HL-DT-ST BD-RE WH16NS60");
             break;
         case IDE_CFATA:
-            strcpy(s->drive_model_str, "QEMU MICRODRIVE");
+            strcpy(s->drive_model_str, "MicroSD J45S9");
             break;
         default:
-            strcpy(s->drive_model_str, "QEMU HARDDISK");
+            strcpy(s->drive_model_str, "Samsung SSD 980 500GB");
             break;
         }
     }
diff --git a/hw/ide/ich.c b/hw/ide/ich.c
--- a/hw/ide/ich.c
+++ b/hw/ide/ich.c
@@ -182,8 +182,8 @@

     k->realize = pci_ich9_ahci_realize;
     k->exit = pci_ich9_uninit;
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
-    k->device_id = PCI_DEVICE_ID_INTEL_82801IR;
+    k->vendor_id = PCI_VENDOR_ID_AMD;
+    k->device_id = PCI_DEVICE_ID_AMD_SATA_CONTROLLER;
     k->revision = 0x02;
     k->class_id = PCI_CLASS_STORAGE_SATA;
     dc->vmsd = &vmstate_ich9_ahci;
diff --git a/hw/input/adb-kbd.c b/hw/input/adb-kbd.c
--- a/hw/input/adb-kbd.c
+++ b/hw/input/adb-kbd.c
@@ -356,7 +356,7 @@
 }

 static const QemuInputHandler adb_keyboard_handler = {
-    .name  = "QEMU ADB Keyboard",
+    .name  = "ADB Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = adb_keyboard_event,
 };
diff --git a/hw/input/adb-mouse.c b/hw/input/adb-mouse.c
--- a/hw/input/adb-mouse.c
+++ b/hw/input/adb-mouse.c
@@ -94,7 +94,7 @@
 }

 static const QemuInputHandler adb_mouse_handler = {
-    .name  = "QEMU ADB Mouse",
+    .name  = "ADB Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = adb_mouse_handle_event,
     /*
diff --git a/hw/input/hid.c b/hw/input/hid.c
--- a/hw/input/hid.c
+++ b/hw/input/hid.c
@@ -511,20 +511,20 @@
 }

 static const QemuInputHandler hid_keyboard_handler = {
-    .name  = "QEMU HID Keyboard",
+    .name  = "HID Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = hid_keyboard_event,
 };

 static const QemuInputHandler hid_mouse_handler = {
-    .name  = "QEMU HID Mouse",
+    .name  = "HID Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
 };

 static const QemuInputHandler hid_tablet_handler = {
-    .name  = "QEMU HID Tablet",
+    .name  = "HID Tablet",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_ABS,
     .event = hid_pointer_event,
     .sync  = hid_pointer_sync,
diff --git a/hw/input/ps2.c b/hw/input/ps2.c
--- a/hw/input/ps2.c
+++ b/hw/input/ps2.c
@@ -1232,7 +1232,7 @@
 };

 static const QemuInputHandler ps2_keyboard_handler = {
-    .name  = "QEMU PS/2 Keyboard",
+    .name  = "PS/2 Keyboard",
     .mask  = INPUT_EVENT_MASK_KEY,
     .event = ps2_keyboard_event,
 };
@@ -1243,7 +1243,7 @@
 }

 static const QemuInputHandler ps2_mouse_handler = {
-    .name  = "QEMU PS/2 Mouse",
+    .name  = "PS/2 Mouse",
     .mask  = INPUT_EVENT_MASK_BTN | INPUT_EVENT_MASK_REL,
     .event = ps2_mouse_event,
     .sync  = ps2_mouse_sync,
diff --git a/hw/input/virtio-input-hid.c b/hw/input/virtio-input-hid.c
--- a/hw/input/virtio-input-hid.c
+++ b/hw/input/virtio-input-hid.c
@@ -16,10 +16,10 @@

 #include "standard-headers/linux/input.h"

-#define VIRTIO_ID_NAME_KEYBOARD     "QEMU Virtio Keyboard"
-#define VIRTIO_ID_NAME_MOUSE        "QEMU Virtio Mouse"
-#define VIRTIO_ID_NAME_TABLET       "QEMU Virtio Tablet"
-#define VIRTIO_ID_NAME_MULTITOUCH   "QEMU Virtio MultiTouch"
+#define VIRTIO_ID_NAME_KEYBOARD     "Keyboard"
+#define VIRTIO_ID_NAME_MOUSE        "Mouse"
+#define VIRTIO_ID_NAME_TABLET       "Tablet"
+#define VIRTIO_ID_NAME_MULTITOUCH   "MultiTouch"

 /* ----------------------------------------------------------------- */

@@ -281,7 +281,7 @@
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x1022), /* same we use for usb hid devices */
             .product = const_le16(0x0001),
             .version = const_le16(0x0001),
         },
@@ -338,7 +338,7 @@
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x1022), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0001),
         },
@@ -363,7 +363,7 @@
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x1022), /* same we use for usb hid devices */
             .product = const_le16(0x0002),
             .version = const_le16(0x0002),
         },
@@ -431,7 +431,7 @@
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x1022), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
@@ -468,7 +468,7 @@
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x1022), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0002),
         },
@@ -555,7 +555,7 @@
         .size      = sizeof(struct virtio_input_devids),
         .u.ids     = {
             .bustype = const_le16(BUS_VIRTUAL),
-            .vendor  = const_le16(0x0627), /* same we use for usb hid devices */
+            .vendor  = const_le16(0x1022), /* same we use for usb hid devices */
             .product = const_le16(0x0003),
             .version = const_le16(0x0001),
         },
diff --git a/hw/isa/lpc_ich9.c b/hw/isa/lpc_ich9.c
--- a/hw/isa/lpc_ich9.c
+++ b/hw/isa/lpc_ich9.c
@@ -889,10 +889,10 @@
     dc->vmsd = &vmstate_ich9_lpc;
     device_class_set_props(dc, ich9_lpc_properties);
     k->config_write = ich9_lpc_config_write;
-    dc->desc = "ICH9 LPC bridge";
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
-    k->device_id = PCI_DEVICE_ID_INTEL_ICH9_8;
-    k->revision = ICH9_A2_LPC_REVISION;
+    dc->desc = "AMD LPC bridge";
+    k->vendor_id = PCI_VENDOR_ID_AMD;
+    k->device_id = PCI_DEVICE_ID_AMD_FCH_LPC_BRIDGE;
+    k->revision = AMD_ICH9Emu_A2_LPC_REVISION;
     k->class_id = PCI_CLASS_BRIDGE_ISA;
     /*
      * Reason: part of ICH9 southbridge, needs to be wired up by
diff --git a/hw/loongarch/virt.c b/hw/loongarch/virt.c
--- a/hw/loongarch/virt.c
+++ b/hw/loongarch/virt.c
@@ -129,13 +129,13 @@
     MachineClass *mc = MACHINE_GET_CLASS(lvms);
     uint8_t *smbios_tables, *smbios_anchor;
     size_t smbios_tables_len, smbios_anchor_len;
-    const char *product = "QEMU Virtual Machine";
+    const char *product = "AMD Machine";

     if (!lvms->fw_cfg) {
         return;
     }

-    smbios_set_defaults("QEMU", product, mc->name);
+    smbios_set_defaults("Unknown", product, mc->name);

     smbios_get_tables(ms, SMBIOS_ENTRY_POINT_TYPE_64,
                       NULL, 0,
diff --git a/hw/m68k/virt.c b/hw/m68k/virt.c
--- a/hw/m68k/virt.c
+++ b/hw/m68k/virt.c
@@ -312,7 +312,7 @@
 static void virt_machine_class_init(ObjectClass *oc, void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
-    mc->desc = "QEMU M68K Virtual Machine";
+    mc->desc = "AMD M68K Machine";
     mc->init = virt_init;
     mc->default_cpu_type = M68K_CPU_TYPE_NAME("m68040");
     mc->max_cpus = 1;
@@ -342,7 +342,7 @@
     { \
         MachineClass *mc = MACHINE_CLASS(oc); \
         MACHINE_VER_SYM(options, virt, __VA_ARGS__)(mc); \
-        mc->desc = "QEMU " MACHINE_VER_STR(__VA_ARGS__) " M68K Virtual Machine"; \
+        mc->desc = "AMD " MACHINE_VER_STR(__VA_ARGS__) " M68K Machine"; \
         MACHINE_VER_DEPRECATION(__VA_ARGS__); \
         if (latest) { \
             mc->alias = "virt"; \
diff --git a/hw/misc/pvpanic-isa.c b/hw/misc/pvpanic-isa.c
--- a/hw/misc/pvpanic-isa.c
+++ b/hw/misc/pvpanic-isa.c
@@ -69,7 +69,7 @@
     PVPanicISAState *s = PVPANIC_ISA_DEVICE(adev);
     Aml *dev = aml_device("PEVT");

-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0001")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0001")));

     crs = aml_resource_template();
     aml_append(crs,
diff --git a/hw/nvme/ctrl.c b/hw/nvme/ctrl.c
--- a/hw/nvme/ctrl.c
+++ b/hw/nvme/ctrl.c
@@ -8786,7 +8786,7 @@

     id->vid = cpu_to_le16(pci_get_word(pci_conf + PCI_VENDOR_ID));
     id->ssvid = cpu_to_le16(pci_get_word(pci_conf + PCI_SUBSYSTEM_VENDOR_ID));
-    strpadcpy((char *)id->mn, sizeof(id->mn), "QEMU NVMe Ctrl", ' ');
+    strpadcpy((char *)id->mn, sizeof(id->mn), "NVMe Ctrl", ' ');
     strpadcpy((char *)id->fr, sizeof(id->fr), QEMU_VERSION, ' ');
     strpadcpy((char *)id->sn, sizeof(id->sn), n->params.serial, ' ');

diff --git a/hw/nvram/fw_cfg-acpi.c b/hw/nvram/fw_cfg-acpi.c
--- a/hw/nvram/fw_cfg-acpi.c
+++ b/hw/nvram/fw_cfg-acpi.c
@@ -11,7 +11,7 @@
 void fw_cfg_acpi_dsdt_add(Aml *scope, const MemMapEntry *fw_cfg_memmap)
 {
     Aml *dev = aml_device("FWCF");
-    aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));
+    aml_append(dev, aml_name_decl("_HID", aml_string("UEFI0002")));
     /* device present, functioning, decoding, not shown in UI */
     aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));
     aml_append(dev, aml_name_decl("_CCA", aml_int(1)));
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -56,7 +56,7 @@
 #define FW_CFG_DMA_CTL_SELECT  0x08
 #define FW_CFG_DMA_CTL_WRITE   0x10

-#define FW_CFG_DMA_SIGNATURE 0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE 0x51434f4d20434647ULL /* "QCOM CFG" */

 struct FWCfgEntry {
     uint32_t len;
@@ -1096,7 +1096,7 @@
         return;
     }

-    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4);
+    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4); // "QEMU"
     fw_cfg_add_bytes(s, FW_CFG_UUID, &qemu_uuid, 16);
     fw_cfg_add_i16(s, FW_CFG_NOGRAPHIC, (uint16_t)!machine->enable_graphics);
     fw_cfg_add_i16(s, FW_CFG_BOOT_MENU, (uint16_t)(machine->boot_config.has_menu && machine->boot_config.menu));
diff --git a/hw/pci-host/gpex.c b/hw/pci-host/gpex.c
--- a/hw/pci-host/gpex.c
+++ b/hw/pci-host/gpex.c
@@ -243,7 +243,7 @@
     DeviceClass *dc = DEVICE_CLASS(klass);

     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
-    dc->desc = "QEMU generic PCIe host bridge";
+    dc->desc = "Generic PCIe host bridge";
     dc->vmsd = &vmstate_gpex_root;
     k->vendor_id = PCI_VENDOR_ID_REDHAT;
     k->device_id = PCI_DEVICE_ID_REDHAT_PCIE_HOST;
diff --git a/hw/pci-host/q35.c b/hw/pci-host/q35.c
--- a/hw/pci-host/q35.c
+++ b/hw/pci-host/q35.c
@@ -679,7 +679,7 @@
     set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
     dc->desc = "Host bridge";
     dc->vmsd = &vmstate_mch;
-    k->vendor_id = PCI_VENDOR_ID_INTEL;
+    k->vendor_id = PCI_VENDOR_ID_AMD;
     /*
      * The 'q35' machine type implements an Intel Series 3 chipset,
      * of which there are several variants. The key difference between
@@ -688,7 +688,7 @@
      * implement integrated graphics, so uses the PCI ID for the 82P35
      * chipset.
      */
-    k->device_id = PCI_DEVICE_ID_INTEL_P35_MCH;
+    k->device_id = PCI_DEVICE_ID_AMD_ROOT_COMPLEX;
     k->revision = MCH_HOST_BRIDGE_REVISION_DEFAULT;
     k->class_id = PCI_CLASS_BRIDGE_HOST;
     /*
diff --git a/hw/ppc/e500plat.c b/hw/ppc/e500plat.c
--- a/hw/ppc/e500plat.c
+++ b/hw/ppc/e500plat.c
@@ -22,7 +22,7 @@

 static void e500plat_fixup_devtree(void *fdt)
 {
-    const char model[] = "QEMU ppce500";
+    const char model[] = "ppce500";
     const char compatible[] = "fsl,qemu-e500";

     qemu_fdt_setprop(fdt, "/", "model", model, sizeof(model));
diff --git a/hw/ppc/pnv.c b/hw/ppc/pnv.c
--- a/hw/ppc/pnv.c
+++ b/hw/ppc/pnv.c
@@ -652,7 +652,7 @@
     _FDT((fdt_create_empty_tree(fdt, FDT_MAX_SIZE)));

     /* /qemu node */
-    _FDT((fdt_add_subnode(fdt, 0, "qemu")));
+    _FDT((fdt_add_subnode(fdt, 0, "qemu"))); // "qemu"

     /* Root node */
     _FDT((fdt_setprop_cell(fdt, 0, "#address-cells", 0x2)));
diff --git a/hw/scsi/mptconfig.c b/hw/scsi/mptconfig.c
--- a/hw/scsi/mptconfig.c
+++ b/hw/scsi/mptconfig.c
@@ -189,12 +189,12 @@
 size_t mptsas_config_manufacturing_0(MPTSASState *s, uint8_t **data, int address)
 {
     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,
-                              "s16s8s16s16s16",
-                              "QEMU MPT Fusion",
+                              "s10s4s85s45s34",
+                              "MPT Fusion",
                               "2.5",
-                              "QEMU MPT Fusion",
-                              "QEMU",
-                              "0000111122223333");
+                              "MPT Fusion",
+                              "MSI",
+                              "7624862998526197");
 }

 static
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -698,8 +698,8 @@
         r->buf[3] = 2 | 0x10; /* HiSup, response data format */
         r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */
         r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */
-        memcpy(&r->buf[8], "QEMU    ", 8);
-        memcpy(&r->buf[16], "QEMU TARGET     ", 16);
+        memcpy(&r->buf[8], "MSI     ", 8);
+        memcpy(&r->buf[16], "MSI TARGET      ", 16);
         pstrcpy((char *) &r->buf[32], 4, qemu_hw_version());
     }
     return true;
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -2568,7 +2568,7 @@
         s->version = g_strdup(qemu_hw_version());
     }
     if (!s->vendor) {
-        s->vendor = g_strdup("QEMU");
+        s->vendor = g_strdup("Samsung");
     }
     if (s->serial && strlen(s->serial) > MAX_SERIAL_LEN) {
         error_setg(errp, "The serial number can't be longer than %d characters",
@@ -2632,7 +2632,7 @@
     s->qdev.blocksize = s->qdev.conf.logical_block_size;
     s->qdev.type = TYPE_DISK;
     if (!s->product) {
-        s->product = g_strdup("QEMU HARDDISK");
+        s->product = g_strdup("Samsung SSD 980 500GB");
     }
     scsi_realize(&s->qdev, errp);
 }
@@ -2659,7 +2659,7 @@
     s->qdev.type = TYPE_ROM;
     s->features |= 1 << SCSI_DISK_F_REMOVABLE;
     if (!s->product) {
-        s->product = g_strdup("QEMU CD-ROM");
+        s->product = g_strdup("CD-ROM");
     }
     scsi_realize(&s->qdev, errp);
 }
diff --git a/hw/scsi/spapr_vscsi.c b/hw/scsi/spapr_vscsi.c
--- a/hw/scsi/spapr_vscsi.c
+++ b/hw/scsi/spapr_vscsi.c
@@ -713,8 +713,8 @@
     resp_data[3] = 0x02;   /* Resp data format */
     resp_data[4] = 36 - 5; /* Additional length */
     resp_data[7] = 0x10;   /* Sync transfers */
-    memcpy(&resp_data[16], "QEMU EMPTY      ", 16);
-    memcpy(&resp_data[8], "QEMU    ", 8);
+    memcpy(&resp_data[16], "MSI EMPTY       ", 16);
+    memcpy(&resp_data[8], "MSI     ", 8);

     req->writing = 0;
     vscsi_preprocess_desc(req);
@@ -971,7 +971,7 @@
 #endif
     memset(&info, 0, sizeof(info));
     strcpy(info.srp_version, SRP_VERSION);
-    memcpy(info.partition_name, "qemu", sizeof("qemu"));
+    memcpy(info.partition_name, "msi", sizeof("msi"));
     info.partition_number = cpu_to_be32(0);
     info.mad_version = cpu_to_be32(1);
     info.os_type = cpu_to_be32(2);
diff --git a/hw/smbios/smbios.c b/hw/smbios/smbios.c
--- a/hw/smbios/smbios.c
+++ b/hw/smbios/smbios.c
@@ -571,11 +571,11 @@

     t->bios_rom_size = 0; /* hardcoded in SeaBIOS with FIXME comment */

-    t->bios_characteristics = cpu_to_le64(0x08); /* Not supported */
+    t->bios_characteristics = cpu_to_le64(0); /* Not supported */
     t->bios_characteristics_extension_bytes[0] = 0;
-    t->bios_characteristics_extension_bytes[1] = 0x14; /* TCD/SVVP | VM */
+    t->bios_characteristics_extension_bytes[1] = 0x0F; /* TCD/SVVP | VM */
     if (smbios_type0.uefi) {
-        t->bios_characteristics_extension_bytes[1] |= 0x08; /* |= UEFI */
+        t->bios_characteristics_extension_bytes[1] |= 0; /* |= UEFI */
     }

     if (smbios_type0.have_major_minor) {
@@ -684,7 +684,7 @@
     snprintf(sock_str, sizeof(sock_str), "%s%2x", type4.sock_pfx, instance);
     SMBIOS_TABLE_SET_STR(4, socket_designation_str, sock_str);
     t->processor_type = 0x03; /* CPU */
-    t->processor_family = 0xfe; /* use Processor Family 2 field */
+    t->processor_family = 0x17; /* use AMD Zen 2 field */
     SMBIOS_TABLE_SET_STR(4, processor_manufacturer_str, type4.manufacturer);
     if (type4.processor_id == 0) {
         t->processor_id[0] = cpu_to_le32(smbios_cpuid_version);
@@ -694,15 +694,15 @@
         t->processor_id[1] = cpu_to_le32(type4.processor_id >> 32);
     }
     SMBIOS_TABLE_SET_STR(4, processor_version_str, type4.version);
-    t->voltage = 0;
-    t->external_clock = cpu_to_le16(0); /* Unknown */
+    t->voltage = 0x8B;
+    t->external_clock = cpu_to_le16(100); /* Unknown */
     t->max_speed = cpu_to_le16(type4.max_speed);
     t->current_speed = cpu_to_le16(type4.current_speed);
     t->status = 0x41; /* Socket populated, CPU enabled */
     t->processor_upgrade = 0x01; /* Other */
-    t->l1_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l2_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
-    t->l3_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
+    t->l1_cache_handle = cpu_to_le16(0x0039); /* N/A */
+    t->l2_cache_handle = cpu_to_le16(0x003A); /* N/A */
+    t->l3_cache_handle = cpu_to_le16(0x003B); /* N/A */
     SMBIOS_TABLE_SET_STR(4, serial_number_str, type4.serial);
     SMBIOS_TABLE_SET_STR(4, asset_tag_number_str, type4.asset);
     SMBIOS_TABLE_SET_STR(4, part_number_str, type4.part);
@@ -715,7 +715,7 @@

     t->thread_count = (threads_per_socket > 255) ? 0xFF : threads_per_socket;

-    t->processor_characteristics = cpu_to_le16(0x02); /* Unknown */
+    t->processor_characteristics = cpu_to_le16(0x04); /* Unknown */
     t->processor_family2 = cpu_to_le16(type4.processor_family);

     if (tbl_len == SMBIOS_TYPE_4_LEN_V30) {
@@ -843,9 +843,9 @@

     SMBIOS_BUILD_TABLE_PRE(16, T16_BASE, true); /* required */

-    t->location = 0x01; /* Other */
+    t->location = 0x03; /* Other */
     t->use = 0x03; /* System memory */
-    t->error_correction = 0x06; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
+    t->error_correction = 0x03; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
     size_kb = QEMU_ALIGN_UP(current_machine->ram_size, KiB) / KiB;
     if (size_kb < MAX_T16_STD_SZ) {
         t->maximum_capacity = cpu_to_le32(size_kb);
@@ -872,8 +872,8 @@

     t->physical_memory_array_handle = cpu_to_le16(0x1000); /* Type 16 above */
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->total_width = cpu_to_le16(0xFFFF); /* Unknown */
-    t->data_width = cpu_to_le16(0xFFFF); /* Unknown */
+    t->total_width = cpu_to_le16(64); /* Unknown */
+    t->data_width = cpu_to_le16(64); /* Unknown */
     size_mb = QEMU_ALIGN_UP(size, MiB) / MiB;
     if (size_mb < MAX_T17_STD_SZ) {
         t->size = cpu_to_le16(size_mb);
@@ -888,7 +888,7 @@
     snprintf(loc_str, sizeof(loc_str), "%s %d", type17.loc_pfx, instance);
     SMBIOS_TABLE_SET_STR(17, device_locator_str, loc_str);
     SMBIOS_TABLE_SET_STR(17, bank_locator_str, type17.bank);
-    t->memory_type = 0x07; /* RAM */
+    t->memory_type = 0x1A; /* RAM */
     t->type_detail = cpu_to_le16(0x02); /* Other */
     t->speed = cpu_to_le16(type17.speed);
     SMBIOS_TABLE_SET_STR(17, manufacturer_str, type17.manufacturer);
@@ -897,9 +897,9 @@
     SMBIOS_TABLE_SET_STR(17, part_number_str, type17.part);
     t->attributes = 0; /* Unknown */
     t->configured_clock_speed = t->speed; /* reuse value for max speed */
-    t->minimum_voltage = cpu_to_le16(0); /* Unknown */
-    t->maximum_voltage = cpu_to_le16(0); /* Unknown */
-    t->configured_voltage = cpu_to_le16(0); /* Unknown */
+    t->minimum_voltage = cpu_to_le16(1200); /* Unknown */
+    t->maximum_voltage = cpu_to_le16(1350); /* Unknown */
+    t->configured_voltage = cpu_to_le16(1200); /* Unknown */

     SMBIOS_BUILD_TABLE_POST;
 }
diff --git a/hw/ufs/lu.c b/hw/ufs/lu.c
--- a/hw/ufs/lu.c
+++ b/hw/ufs/lu.c
@@ -184,8 +184,8 @@
     outbuf[5] = 0;
     outbuf[6] = 0;
     outbuf[7] = 0x2;
-    strpadcpy((char *)&outbuf[8], 8, "QEMU", ' ');
-    strpadcpy((char *)&outbuf[16], 16, "QEMU UFS", ' ');
+    strpadcpy((char *)&outbuf[8], 8, "MSI", ' ');
+    strpadcpy((char *)&outbuf[16], 16, "UFS", ' ');
     memset(&outbuf[32], 0, 4);

     return SCSI_INQUIRY_LEN;
diff --git a/hw/usb/canokey.c b/hw/usb/canokey.c
--- a/hw/usb/canokey.c
+++ b/hw/usb/canokey.c
@@ -35,8 +35,8 @@

 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER]     = "canokeys.org",
-    [STR_PRODUCT]          = "CanoKey QEMU",
-    [STR_SERIALNUMBER]     = "0"
+    [STR_PRODUCT]          = "CanoKey Canary",
+    [STR_SERIALNUMBER]     = "JTU72VDVWE"
 };

 static const USBDescDevice desc_device_canokey = {
diff --git a/hw/usb/dev-audio.c b/hw/usb/dev-audio.c
--- a/hw/usb/dev-audio.c
+++ b/hw/usb/dev-audio.c
@@ -73,9 +73,9 @@
 };

 static const USBDescStrings usb_audio_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "QEMU USB Audio",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Logitech",
+    [STRING_PRODUCT]            = "USB Audio",
+    [STRING_SERIALNUMBER]       = "IRNUSNFLX1",
     [STRING_CONFIG]             = "Audio Configuration",
     [STRING_USBAUDIO_CONTROL]   = "Audio Device",
     [STRING_INPUT_TERMINAL]     = "Audio Output Pipe",
diff --git a/hw/usb/dev-hid.c b/hw/usb/dev-hid.c
--- a/hw/usb/dev-hid.c
+++ b/hw/usb/dev-hid.c
@@ -63,17 +63,17 @@
 };

 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
-    [STR_PRODUCT_MOUSE]    = "QEMU USB Mouse",
-    [STR_PRODUCT_TABLET]   = "QEMU USB Tablet",
-    [STR_PRODUCT_KEYBOARD] = "QEMU USB Keyboard",
-    [STR_SERIAL_COMPAT]    = "42",
+    [STR_MANUFACTURER]     = "Logitech",
+    [STR_PRODUCT_MOUSE]    = "USB Mouse",
+    [STR_PRODUCT_TABLET]   = "USB Tablet",
+    [STR_PRODUCT_KEYBOARD] = "USB Keyboard",
+    [STR_SERIAL_COMPAT]    = "42",
     [STR_CONFIG_MOUSE]     = "HID Mouse",
     [STR_CONFIG_TABLET]    = "HID Tablet",
     [STR_CONFIG_KEYBOARD]  = "HID Keyboard",
-    [STR_SERIAL_MOUSE]     = "89126",
-    [STR_SERIAL_TABLET]    = "28754",
-    [STR_SERIAL_KEYBOARD]  = "68284",
+    [STR_SERIAL_MOUSE]     = "BSGMMXHEP7",
+    [STR_SERIAL_TABLET]    = "ERYV8E95VE",
+    [STR_SERIAL_KEYBOARD]  = "FVVBDBHDBN",
 };

 static const USBDescIface desc_iface_mouse = {
@@ -368,7 +368,7 @@

 static const USBDesc desc_mouse = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -382,7 +382,7 @@

 static const USBDesc desc_mouse2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -397,7 +397,7 @@

 static const USBDesc desc_tablet = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -411,7 +411,7 @@

 static const USBDesc desc_tablet2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -426,7 +426,7 @@

 static const USBDesc desc_keyboard = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -440,7 +440,7 @@

 static const USBDesc desc_keyboard2 = {
     .id = {
-        .idVendor          = 0x0627,
+        .idVendor          = 0x1022,
         .idProduct         = 0x0001,
         .bcdDevice         = 0,
         .iManufacturer     = STR_MANUFACTURER,
@@ -805,7 +805,7 @@
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);

     uc->realize        = usb_tablet_realize;
-    uc->product_desc   = "QEMU USB Tablet";
+    uc->product_desc   = "USB Tablet";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_tablet_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -827,7 +827,7 @@
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);

     uc->realize        = usb_mouse_realize;
-    uc->product_desc   = "QEMU USB Mouse";
+    uc->product_desc   = "USB Mouse";
     dc->vmsd = &vmstate_usb_ptr;
     device_class_set_props(dc, usb_mouse_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
@@ -850,7 +850,7 @@
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);

     uc->realize        = usb_keyboard_realize;
-    uc->product_desc   = "QEMU USB Keyboard";
+    uc->product_desc   = "USB Keyboard";
     dc->vmsd = &vmstate_usb_kbd;
     device_class_set_props(dc, usb_keyboard_properties);
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
diff --git a/hw/usb/dev-hub.c b/hw/usb/dev-hub.c
--- a/hw/usb/dev-hub.c
+++ b/hw/usb/dev-hub.c
@@ -104,9 +104,9 @@
 };

 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB Hub",
-    [STR_SERIALNUMBER] = "314159",
+    [STR_MANUFACTURER] = "Logitech",
+    [STR_PRODUCT]      = "USB Hub",
+    [STR_SERIALNUMBER] = "NRLQOVZPSD",
 };

 static const USBDescIface desc_iface_hub = {
@@ -676,7 +676,7 @@
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);

     uc->realize        = usb_hub_realize;
-    uc->product_desc   = "QEMU USB Hub";
+    uc->product_desc   = "USB Hub";
     uc->usb_desc       = &desc_hub;
     uc->find_device    = usb_hub_find_device;
     uc->handle_reset   = usb_hub_handle_reset;
diff --git a/hw/usb/dev-mtp.c b/hw/usb/dev-mtp.c
--- a/hw/usb/dev-mtp.c
+++ b/hw/usb/dev-mtp.c
@@ -247,8 +247,8 @@

 /* ----------------------------------------------------------------------- */

-#define MTP_MANUFACTURER  "QEMU"
-#define MTP_PRODUCT       "QEMU filesharing"
+#define MTP_MANUFACTURER  "Microsoft"
+#define MTP_PRODUCT       "filesharing"
 #define MTP_WRITE_BUF_SZ  (512 * KiB)

 enum {
@@ -264,7 +264,7 @@
 static const USBDescStrings desc_strings = {
     [STR_MANUFACTURER] = MTP_MANUFACTURER,
     [STR_PRODUCT]      = MTP_PRODUCT,
-    [STR_SERIALNUMBER] = "34617",
+    [STR_SERIALNUMBER] = "LFI8O4KH2O",
     [STR_MTP]          = "MTP",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
@@ -2090,7 +2090,7 @@
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);

     uc->realize        = usb_mtp_realize;
-    uc->product_desc   = "QEMU USB MTP";
+    uc->product_desc   = "USB MTP";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_mtp_cancel_packet;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-network.c b/hw/usb/dev-network.c
--- a/hw/usb/dev-network.c
+++ b/hw/usb/dev-network.c
@@ -99,16 +99,16 @@
 #define ETH_FRAME_LEN                   1514 /* Max. octets in frame sans FCS */

 static const USBDescStrings usb_net_stringtable = {
-    [STRING_MANUFACTURER]       = "QEMU",
-    [STRING_PRODUCT]            = "RNDIS/QEMU USB Network Device",
-    [STRING_ETHADDR]            = "400102030405",
-    [STRING_DATA]               = "QEMU USB Net Data Interface",
-    [STRING_CONTROL]            = "QEMU USB Net Control Interface",
-    [STRING_RNDIS_CONTROL]      = "QEMU USB Net RNDIS Control Interface",
-    [STRING_CDC]                = "QEMU USB Net CDC",
-    [STRING_SUBSET]             = "QEMU USB Net Subset",
-    [STRING_RNDIS]              = "QEMU USB Net RNDIS",
-    [STRING_SERIALNUMBER]       = "1",
+    [STRING_MANUFACTURER]       = "Realtek",
+    [STRING_PRODUCT]            = "RNDIS/Realtek USB Network Device",
+    [STRING_ETHADDR]            = "4C82A94C9ECA",
+    [STRING_DATA]               = "USB Net Data Interface",
+    [STRING_CONTROL]            = "USB Net Control Interface",
+    [STRING_RNDIS_CONTROL]      = "USB Net RNDIS Control Interface",
+    [STRING_CDC]                = "USB Net CDC",
+    [STRING_SUBSET]             = "USB Net Subset",
+    [STRING_RNDIS]              = "USB Net RNDIS",
+    [STRING_SERIALNUMBER]       = "2WAT53WJS2",
 };

 static const USBDescIface desc_iface_rndis[] = {
@@ -717,7 +717,7 @@

     /* mandatory */
     case OID_GEN_VENDOR_DESCRIPTION:
-        pstrcpy((char *)outbuf, outlen, "QEMU USB RNDIS Net");
+        pstrcpy((char *)outbuf, outlen, "USB RNDIS Net");
         return strlen((char *)outbuf) + 1;

     case OID_GEN_VENDOR_DRIVER_VERSION:
@@ -1417,7 +1417,7 @@
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);

     uc->realize        = usb_net_realize;
-    uc->product_desc   = "QEMU USB Network Interface";
+    uc->product_desc   = "USB Network Interface";
     uc->usb_desc       = &desc_net;
     uc->handle_reset   = usb_net_handle_reset;
     uc->handle_control = usb_net_handle_control;
diff --git a/hw/usb/dev-serial.c b/hw/usb/dev-serial.c
--- a/hw/usb/dev-serial.c
+++ b/hw/usb/dev-serial.c
@@ -119,10 +119,10 @@
 };

 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]    = "QEMU",
-    [STR_PRODUCT_SERIAL]  = "QEMU USB SERIAL",
-    [STR_PRODUCT_BRAILLE] = "QEMU USB BAUM BRAILLE",
-    [STR_SERIALNUMBER]    = "1",
+    [STR_MANUFACTURER]    = "Microsoft",
+    [STR_PRODUCT_SERIAL]  = "USB SERIAL",
+    [STR_PRODUCT_BRAILLE] = "USB BAUM BRAILLE",
+    [STR_SERIALNUMBER]    = "0GBVO35AQT",
 };

 static const USBDescIface desc_iface0 = {
@@ -665,7 +665,7 @@
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);

-    uc->product_desc   = "QEMU USB Serial";
+    uc->product_desc   = "USB Serial";
     uc->usb_desc       = &desc_serial;
     device_class_set_props(dc, serial_properties);
 }
@@ -685,7 +685,7 @@
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);

-    uc->product_desc   = "QEMU USB Braille";
+    uc->product_desc   = "USB Braille";
     uc->usb_desc       = &desc_braille;
     device_class_set_props(dc, braille_properties);
 }
diff --git a/hw/usb/dev-smartcard-reader.c b/hw/usb/dev-smartcard-reader.c
--- a/hw/usb/dev-smartcard-reader.c
+++ b/hw/usb/dev-smartcard-reader.c
@@ -80,8 +80,8 @@
 #define CCID_CONTROL_GET_CLOCK_FREQUENCIES  0x2
 #define CCID_CONTROL_GET_DATA_RATES         0x3

-#define CCID_PRODUCT_DESCRIPTION        "QEMU USB CCID"
-#define CCID_VENDOR_DESCRIPTION         "QEMU"
+#define CCID_PRODUCT_DESCRIPTION        "USB CCID"
+#define CCID_VENDOR_DESCRIPTION         "Identiv"
 #define CCID_INTERFACE_NAME             "CCID Interface"
 #define CCID_SERIAL_NUMBER_STRING       "1"
 /*
@@ -419,9 +419,9 @@
 };

 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]  = "QEMU",
-    [STR_PRODUCT]       = "QEMU USB CCID",
-    [STR_SERIALNUMBER]  = "1",
+    [STR_MANUFACTURER]  = "Identiv",
+    [STR_PRODUCT]       = "USB CCID",
+    [STR_SERIALNUMBER]  = "RKW9A9EBXN",
     [STR_INTERFACE]     = "CCID Interface",
 };

@@ -1441,7 +1441,7 @@
     HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(klass);

     uc->realize        = ccid_realize;
-    uc->product_desc   = "QEMU USB CCID";
+    uc->product_desc   = "USB CCID";
     uc->usb_desc       = &desc_ccid;
     uc->handle_reset   = ccid_handle_reset;
     uc->handle_control = ccid_handle_control;
diff --git a/hw/usb/dev-storage.c b/hw/usb/dev-storage.c
--- a/hw/usb/dev-storage.c
+++ b/hw/usb/dev-storage.c
@@ -47,9 +47,9 @@
 };

 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
-    [STR_PRODUCT]      = "QEMU USB HARDDRIVE",
-    [STR_SERIALNUMBER] = "1",
+    [STR_MANUFACTURER] = "Samsung",
+    [STR_PRODUCT]      = "USB HARDDRIVE",
+    [STR_SERIALNUMBER] = "8RIGSFEUOF",
     [STR_CONFIG_FULL]  = "Full speed config (usb 1.1)",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
@@ -590,7 +590,7 @@
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);

-    uc->product_desc   = "QEMU USB MSD";
+    uc->product_desc   = "USB MSD";
     uc->usb_desc       = &desc;
     uc->cancel_packet  = usb_msd_cancel_io;
     uc->handle_attach  = usb_desc_attach;
diff --git a/hw/usb/dev-uas.c b/hw/usb/dev-uas.c
--- a/hw/usb/dev-uas.c
+++ b/hw/usb/dev-uas.c
@@ -171,9 +171,9 @@
 };

 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER] = "QEMU",
+    [STR_MANUFACTURER] = "Microsoft",
     [STR_PRODUCT]      = "USB Attached SCSI HBA",
-    [STR_SERIALNUMBER] = "27842",
+    [STR_SERIALNUMBER] = "SWVKSP0E71",
     [STR_CONFIG_HIGH]  = "High speed config (usb 2.0)",
     [STR_CONFIG_SUPER] = "Super speed config (usb 3.0)",
 };
diff --git a/hw/usb/dev-wacom.c b/hw/usb/dev-wacom.c
--- a/hw/usb/dev-wacom.c
+++ b/hw/usb/dev-wacom.c
@@ -64,9 +64,9 @@
 };

 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Wacom",
     [STR_PRODUCT]          = "Wacom PenPartner",
-    [STR_SERIALNUMBER]     = "1",
+    [STR_SERIALNUMBER]     = "2UMLAOCKUI",
 };

 static const uint8_t qemu_wacom_hid_report_descriptor[] = {
@@ -231,7 +231,7 @@

     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_mouse_event, s, 0,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -269,7 +269,7 @@

     if (!s->mouse_grabbed) {
         s->eh_entry = qemu_add_mouse_event_handler(usb_wacom_event, s, 1,
-                        "QEMU PenPartner tablet");
+                        "PenPartner tablet");
         qemu_activate_mouse_event_handler(s->eh_entry);
         s->mouse_grabbed = 1;
     }
@@ -425,7 +425,7 @@
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);

-    uc->product_desc   = "QEMU PenPartner Tablet";
+    uc->product_desc   = "PenPartner Tablet";
     uc->usb_desc       = &desc_wacom;
     uc->realize        = usb_wacom_realize;
     uc->handle_reset   = usb_wacom_handle_reset;
@@ -433,7 +433,7 @@
     uc->handle_data    = usb_wacom_handle_data;
     uc->unrealize      = usb_wacom_unrealize;
     set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
-    dc->desc = "QEMU PenPartner Tablet";
+    dc->desc = "PenPartner Tablet";
     dc->vmsd = &vmstate_usb_wacom;
 }

diff --git a/hw/usb/hcd-uhci.c b/hw/usb/hcd-uhci.c
--- a/hw/usb/hcd-uhci.c
+++ b/hw/usb/hcd-uhci.c
@@ -1312,8 +1312,8 @@
 static UHCIInfo uhci_info[] = {
     {
         .name      = TYPE_PIIX3_USB_UHCI,
-        .vendor_id = PCI_VENDOR_ID_INTEL,
-        .device_id = PCI_DEVICE_ID_INTEL_82371SB_2,
+        .vendor_id = PCI_VENDOR_ID_AMD,
+        .device_id = PCI_DEVICE_ID_AMD_USB_XHCI_CONTROLLER, // TODO: Find proper deviceid for AMD UHCI USB Controller
         .revision  = 0x01,
         .irq_pin   = 3,
         .unplug    = true,
diff --git a/hw/usb/hcd-xhci-pci.c b/hw/usb/hcd-xhci-pci.c
--- a/hw/usb/hcd-xhci-pci.c
+++ b/hw/usb/hcd-xhci-pci.c
@@ -259,8 +259,8 @@
 {
     PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

-    k->vendor_id    = PCI_VENDOR_ID_REDHAT;
-    k->device_id    = PCI_DEVICE_ID_REDHAT_XHCI;
+    k->vendor_id    = PCI_VENDOR_ID_AMD;
+    k->device_id    = PCI_DEVICE_ID_AMD_USB_XHCI_CONTROLLER;
     k->revision     = 0x01;
 }

diff --git a/hw/usb/u2f.c b/hw/usb/u2f.c
--- a/hw/usb/u2f.c
+++ b/hw/usb/u2f.c
@@ -46,9 +46,9 @@
 };

 static const USBDescStrings desc_strings = {
-    [STR_MANUFACTURER]     = "QEMU",
+    [STR_MANUFACTURER]     = "Microsoft",
     [STR_PRODUCT]          = "U2F USB key",
-    [STR_SERIALNUMBER]     = "0",
+    [STR_SERIALNUMBER]     = "Y0KH87XGM3",
     [STR_CONFIG]           = "U2F key config",
     [STR_INTERFACE]        = "U2F key interface"
 };
@@ -322,7 +322,7 @@
     DeviceClass *dc = DEVICE_CLASS(klass);
     USBDeviceClass *uc = USB_DEVICE_CLASS(klass);

-    uc->product_desc   = "QEMU U2F USB key";
+    uc->product_desc   = "U2F USB key";
     uc->usb_desc       = &desc_u2f_key;
     uc->handle_reset   = u2f_key_handle_reset;
     uc->handle_control = u2f_key_handle_control;
@@ -330,7 +330,7 @@
     uc->handle_attach  = usb_desc_attach;
     uc->realize        = u2f_key_realize;
     uc->unrealize      = u2f_key_unrealize;
-    dc->desc           = "QEMU U2F key";
+    dc->desc           = "U2F key";
     dc->vmsd           = &vmstate_u2f_key;
 }

diff --git a/hw/usb/u2f-emulated.c b/hw/usb/u2f-emulated.c
--- a/hw/usb/u2f-emulated.c
+++ b/hw/usb/u2f-emulated.c
@@ -385,7 +385,7 @@
     kc->realize = u2f_emulated_realize;
     kc->unrealize = u2f_emulated_unrealize;
     kc->recv_from_guest = u2f_emulated_recv_from_guest;
-    dc->desc = "QEMU U2F emulated key";
+    dc->desc = "U2F emulated key";
     device_class_set_props(dc, u2f_emulated_properties);
 }

diff --git a/hw/usb/u2f-passthru.c b/hw/usb/u2f-passthru.c
--- a/hw/usb/u2f-passthru.c
+++ b/hw/usb/u2f-passthru.c
@@ -528,7 +528,7 @@
     kc->realize = u2f_passthru_realize;
     kc->unrealize = u2f_passthru_unrealize;
     kc->recv_from_guest = u2f_passthru_recv_from_guest;
-    dc->desc = "QEMU U2F passthrough key";
+    dc->desc = "U2F passthrough key";
     dc->vmsd = &u2f_passthru_vmstate;
     device_class_set_props(dc, u2f_passthru_properties);
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
diff --git a/hw/vfio/ap.c b/hw/vfio/ap.c
--- a/hw/vfio/ap.c
+++ b/hw/vfio/ap.c
@@ -254,7 +254,7 @@
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
     dc->realize = vfio_ap_realize;
     dc->unrealize = vfio_ap_unrealize;
-    dc->hotpluggable = true;
+    dc->hotpluggable = false;
     device_class_set_legacy_reset(dc, vfio_ap_reset);
     dc->bus_type = TYPE_AP_BUS;

diff --git a/include/hw/acpi/aml-build.h b/include/hw/acpi/aml-build.h
--- a/include/hw/acpi/aml-build.h
+++ b/include/hw/acpi/aml-build.h
@@ -4,8 +4,8 @@
 #include "hw/acpi/acpi-defs.h"
 #include "hw/acpi/bios-linker-loader.h"

-#define ACPI_BUILD_APPNAME6 "BOCHS "
-#define ACPI_BUILD_APPNAME8 "BXPC    "
+#define ACPI_BUILD_APPNAME6 "ALASKA"
+#define ACPI_BUILD_APPNAME8 "A M I   "

 #define ACPI_BUILD_TABLE_FILE "etc/acpi/tables"
 #define ACPI_BUILD_RSDP_FILE "etc/acpi/rsdp"
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -57,12 +57,12 @@
 #define PCI_DEVICE_ID_MARVELL_GT6412X    0x4620

 /* QEMU/Bochs VGA (0x1234) */
-#define PCI_VENDOR_ID_QEMU               0x1234
+#define PCI_VENDOR_ID_QEMU               0x1022 // AMD Vendor ID Replacement from 0x1234
 #define PCI_DEVICE_ID_QEMU_VGA           0x1111
 #define PCI_DEVICE_ID_QEMU_IPMI          0x1112

 /* VMWare (0x15ad) */
-#define PCI_VENDOR_ID_VMWARE             0x15ad
+#define PCI_VENDOR_ID_VMWARE             0x1022 // AMD Vendor ID Replacement from 0x15ad
 #define PCI_DEVICE_ID_VMWARE_SVGA2       0x0405
 #define PCI_DEVICE_ID_VMWARE_SVGA        0x0710
 #define PCI_DEVICE_ID_VMWARE_NET         0x0720
@@ -77,9 +77,9 @@
 #define PCI_DEVICE_ID_INTEL_82801IR      0x2922

 /* Red Hat / Qumranet (for QEMU) -- see pci-ids.txt */
-#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1af4
-#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1af4
-#define PCI_SUBDEVICE_ID_QEMU            0x1100
+#define PCI_VENDOR_ID_REDHAT_QUMRANET    0x1022 // AMD Vendor ID Replacement from 0x1af4
+#define PCI_SUBVENDOR_ID_REDHAT_QUMRANET 0x1022 // AMD Vendor ID Replacement from 0x1af4
+#define PCI_SUBDEVICE_ID_QEMU            0x1022 // AMD Vendor ID Replacement from 0x1100

 /* legacy virtio-pci devices */
 #define PCI_DEVICE_ID_VIRTIO_NET         0x1000
@@ -100,21 +100,21 @@
  */
 #define PCI_DEVICE_ID_VIRTIO_10_BASE     0x1040

-#define PCI_VENDOR_ID_REDHAT             0x1b36
-#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x0001
+#define PCI_VENDOR_ID_REDHAT             0x1022 // AMD Vendor ID Replacement from 0x1b36
+#define PCI_DEVICE_ID_REDHAT_BRIDGE      0x1482 // AMD Vendor ID Replacement from 0x0001
 #define PCI_DEVICE_ID_REDHAT_SERIAL      0x0002
 #define PCI_DEVICE_ID_REDHAT_SERIAL2     0x0003
 #define PCI_DEVICE_ID_REDHAT_SERIAL4     0x0004
 #define PCI_DEVICE_ID_REDHAT_TEST        0x0005
 #define PCI_DEVICE_ID_REDHAT_ROCKER      0x0006
 #define PCI_DEVICE_ID_REDHAT_SDHCI       0x0007
-#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x0008
+#define PCI_DEVICE_ID_REDHAT_PCIE_HOST   0x1482 // AMD Vendor ID Replacement from 0x0008
 #define PCI_DEVICE_ID_REDHAT_PXB         0x0009
 #define PCI_DEVICE_ID_REDHAT_BRIDGE_SEAT 0x000a
 #define PCI_DEVICE_ID_REDHAT_PXB_PCIE    0x000b
-#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x000c
-#define PCI_DEVICE_ID_REDHAT_XHCI        0x000d
-#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x000e
+#define PCI_DEVICE_ID_REDHAT_PCIE_RP     0x1483 // AMD Vendor ID Replacement from 0x000c
+#define PCI_DEVICE_ID_REDHAT_XHCI        0x000d // DON'T MODIFY; Already modified in 'hcd-xhci-pci.c'
+#define PCI_DEVICE_ID_REDHAT_PCIE_BRIDGE 0x1483 // AMD Device ID Replacement from 0x000e
 #define PCI_DEVICE_ID_REDHAT_MDPY        0x000f
 #define PCI_DEVICE_ID_REDHAT_NVME        0x0010
 #define PCI_DEVICE_ID_REDHAT_PVPANIC     0x0011
@@ -123,6 +123,16 @@
 #define PCI_DEVICE_ID_REDHAT_RISCV_IOMMU 0x0014
 #define PCI_DEVICE_ID_REDHAT_QXL         0x0100

+////////// CUSTOM PCI DEVICE ENTRIES //////////
+
+/* https://www.pcilookup.com/ */
+
+#define PCI_VENDOR_ID_AMD                 0x1022 // AMD Vendor ID
+#define PCI_DEVICE_ID_AMD_SATA_CONTROLLER 0x43C8 // 400 Series Chipset SATA Controller
+#define PCI_DEVICE_ID_VIRTIO_INTEL_HD     0x0416 // 4th Gen Core Processor Integrated Graphics Controller
+
+///////////////////////////////////////////////
+
 #define FMT_PCIBUS                      PRIx64

 typedef uint64_t pcibus_t;
diff --git a/include/hw/pci/pci_ids.h b/include/hw/pci/pci_ids.h
--- a/include/hw/pci/pci_ids.h
+++ b/include/hw/pci/pci_ids.h
@@ -179,6 +179,18 @@
 #define PCI_DEVICE_ID_AMD_LANCE          0x2000
 #define PCI_DEVICE_ID_AMD_SCSI           0x2020

+////////// CUSTOM PCI DEVICE ENTRIES //////////
+
+/* https://www.pcilookup.com/ */
+
+#define PCI_DEVICE_ID_AMD_FCH_LPC_BRIDGE       0x790e // FCH LPC Bridge
+#define PCI_DEVICE_ID_AMD_FCH_SMBUS_CONTROLLER 0x790b // FCH SMBus Controller
+#define PCI_DEVICE_ID_AMD_ROOT_COMPLEX         0x1480 // Starship/Matisse Root Complex
+#define PCI_DEVICE_ID_AMD_USB_XHCI_CONTROLLER  0x43ee // 500 Series Chipset USB 3.1 XHCI Controller
+// #define PCI_DEVICE_ID_AMD_USB_UHCI_CONTROLLER 0x???? // TODO: Find proper deviceid for AMD UHCI USB Controller
+
+///////////////////////////////////////////////
+
 #define PCI_VENDOR_ID_HP                 0x103c

 #define PCI_VENDOR_ID_TI                 0x104c
@@ -247,6 +259,7 @@
 #define PCI_DEVICE_ID_INTEL_NVME         0x5845
 #define PCI_DEVICE_ID_INTEL_82371SB_0    0x7000
 #define PCI_DEVICE_ID_INTEL_82371SB_1    0x7010
+// Intel 82371SB PIIX3 - USB Controller [B-0]
 #define PCI_DEVICE_ID_INTEL_82371SB_2    0x7020
 #define PCI_DEVICE_ID_INTEL_82371AB_0    0x7110
 #define PCI_DEVICE_ID_INTEL_82371AB      0x7111
@@ -259,9 +272,13 @@
 #define PCI_DEVICE_ID_INTEL_ICH9_3       0x2913
 #define PCI_DEVICE_ID_INTEL_ICH9_4       0x2914
 #define PCI_DEVICE_ID_INTEL_ICH9_5       0x2919
+// Intel 82801IB ICH9 - SMBus Controller [A2]
 #define PCI_DEVICE_ID_INTEL_ICH9_6       0x2930
+// Intel RV/RN/Bixby FCH - SMBus and ACPI Controller
 #define PCI_DEVICE_ID_INTEL_ICH9_7       0x2916
-#define PCI_DEVICE_ID_INTEL_ICH9_8       0x2918
+// AuthenticAMD DeviceID
+// AMD Family 17h/19h - Root Complex
+#define PCI_DEVICE_ID_INTEL_ICH9_8       0x1480 // AMD Vendor ID Replacement from 0x2918

 #define PCI_DEVICE_ID_INTEL_82801I_UHCI1 0x2934
 #define PCI_DEVICE_ID_INTEL_82801I_UHCI2 0x2935
@@ -275,7 +292,7 @@

 #define PCI_DEVICE_ID_INTEL_P35_MCH      0x29c0

-#define PCI_VENDOR_ID_XEN                0x5853
+#define PCI_VENDOR_ID_XEN                0x1022 // AMD Vendor ID Replacement from 0x5853
 #define PCI_DEVICE_ID_XEN_PLATFORM       0x0001

 #define PCI_VENDOR_ID_NEC                0x1033
@@ -284,7 +301,7 @@
 #define PCI_VENDOR_ID_TEWS               0x1498
 #define PCI_DEVICE_ID_TEWS_TPCI200       0x30C8

-#define PCI_VENDOR_ID_VMWARE             0x15ad
+#define PCI_VENDOR_ID_VMWARE             0x1022 // AMD Vendor ID Replacement from 0x15ad
 #define PCI_DEVICE_ID_VMWARE_PVRDMA      0x0820

 #define PCI_VENDOR_ID_SYNOPSYS           0x16C3
diff --git a/include/hw/southbridge/ich9.h b/include/hw/southbridge/ich9.h
--- a/include/hw/southbridge/ich9.h
+++ b/include/hw/southbridge/ich9.h
@@ -129,6 +129,7 @@
 #define ICH9_LPC_FUNC                           0

 #define ICH9_A2_LPC_REVISION                    0x2
+#define AMD_ICH9Emu_A2_LPC_REVISION             0x51 // TODO: Double check device id
 #define ICH9_LPC_NB_PIRQS                       8       /* PCI A-H */

 #define ICH9_LPC_PMBASE                         0x40
@@ -214,6 +215,7 @@
 #define TYPE_ICH9_SMB_DEVICE "ICH9-SMB"

 #define ICH9_A2_SMB_REVISION                    0x02
+#define AMD_ICH9Emu_A2_SMB_REVISION             0x61 // TODO: Double check device id
 #define ICH9_SMB_PI                             0x00

 #define ICH9_SMB_SMBMBAR0                       0x10
diff --git a/include/standard-headers/linux/qemu_fw_cfg.h b/include/standard-headers/linux/qemu_fw_cfg.h
--- a/include/standard-headers/linux/qemu_fw_cfg.h
+++ b/include/standard-headers/linux/qemu_fw_cfg.h
@@ -4,7 +4,7 @@

 #include "standard-headers/linux/types.h"

-#define FW_CFG_ACPI_DEVICE_ID	"QEMU0002"
+#define FW_CFG_ACPI_DEVICE_ID	"UEFI0002"

 /* selector key values for "well-known" fw_cfg entries */
 #define FW_CFG_SIGNATURE	0x00
@@ -71,7 +71,7 @@
 #define FW_CFG_DMA_CTL_SELECT	0x08
 #define FW_CFG_DMA_CTL_WRITE	0x10

-#define FW_CFG_DMA_SIGNATURE    0x51454d5520434647ULL /* "QEMU CFG" */
+#define FW_CFG_DMA_SIGNATURE    0x51434f4d20434647ULL /* "QCOM CFG" */

 /* Control as first field allows for different structures selected by this
  * field, which might be useful in the future
diff --git a/migration/rdma.c b/migration/rdma.c
--- a/migration/rdma.c
+++ b/migration/rdma.c
@@ -220,7 +220,7 @@
         [RDMA_CONTROL_NONE] = "NONE",
         [RDMA_CONTROL_ERROR] = "ERROR",
         [RDMA_CONTROL_READY] = "READY",
-        [RDMA_CONTROL_QEMU_FILE] = "QEMU FILE",
+        [RDMA_CONTROL_QEMU_FILE] = "FILE",
         [RDMA_CONTROL_RAM_BLOCKS_REQUEST] = "RAM BLOCKS REQUEST",
         [RDMA_CONTROL_RAM_BLOCKS_RESULT] = "RAM BLOCKS RESULT",
         [RDMA_CONTROL_COMPRESS] = "COMPRESS",
diff --git a/pc-bios/s390-ccw/virtio-scsi.h b/pc-bios/s390-ccw/virtio-scsi.h
--- a/pc-bios/s390-ccw/virtio-scsi.h
+++ b/pc-bios/s390-ccw/virtio-scsi.h
@@ -25,7 +25,7 @@
 #define VIRTIO_SCSI_S_OK                     0x00
 #define VIRTIO_SCSI_S_BAD_TARGET             0x03

-#define QEMU_CDROM_SIGNATURE "QEMU CD-ROM     "
+#define QEMU_CDROM_SIGNATURE "ASUS CD-ROM     "

 enum virtio_scsi_vq_id {
     VR_CONTROL  = 0,
diff --git a/qapi/ui.json b/qapi/ui.json
--- a/qapi/ui.json
+++ b/qapi/ui.json
@@ -831,13 +831,13 @@
 #     -> { "execute": "query-mice" }
 #     <- { "return": [
 #              {
-#                 "name":"QEMU Microsoft Mouse",
+#                 "name":"Microsoft Mouse",
 #                 "index":0,
 #                 "current":false,
 #                 "absolute":false
 #              },
 #              {
-#                 "name":"QEMU PS/2 Mouse",
+#                 "name":"PS/2 Mouse",
 #                 "index":1,
 #                 "current":true,
 #                 "absolute":true
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -2500,7 +2500,7 @@
         .features[FEAT_8000_0001_ECX] =
             CPUID_EXT3_LAHF_LM | CPUID_EXT3_SVM,
         .xlevel = 0x8000000A,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "phenom",
@@ -2615,7 +2615,7 @@
              VMX_CPU_BASED_UNCOND_IO_EXITING | VMX_CPU_BASED_USE_IO_BITMAPS |
              VMX_CPU_BASED_MONITOR_EXITING | VMX_CPU_BASED_PAUSE_EXITING,
         .xlevel = 0x80000008,
-        .model_id = "Common KVM processor"
+        .model_id = "Common AMD processor"
     },
     {
         .name = "qemu32",
@@ -2629,7 +2629,7 @@
         .features[FEAT_1_ECX] =
             CPUID_EXT_SSE3,
         .xlevel = 0x80000004,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "kvm32",
@@ -2659,7 +2659,7 @@
              VMX_CPU_BASED_USE_IO_BITMAPS | VMX_CPU_BASED_MONITOR_EXITING |
              VMX_CPU_BASED_PAUSE_EXITING | VMX_CPU_BASED_USE_MSR_BITMAPS,
         .xlevel = 0x80000008,
-        .model_id = "Common 32-bit KVM processor"
+        .model_id = "Common 32-bit AMD processor"
     },
     {
         .name = "coreduo",
@@ -2755,7 +2755,7 @@
         .features[FEAT_8000_0001_EDX] =
             CPUID_EXT2_MMXEXT | CPUID_EXT2_3DNOW | CPUID_EXT2_3DNOWEXT,
         .xlevel = 0x80000008,
-        .model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION,
+        .model_id = "AMD CPU version " QEMU_HW_VERSION,
     },
     {
         .name = "n270",
@@ -5720,7 +5720,7 @@
     object_property_set_str(OBJECT(cpu), "vendor", CPUID_VENDOR_AMD,
                             &error_abort);
     object_property_set_str(OBJECT(cpu), "model-id",
-                            "QEMU TCG CPU version " QEMU_HW_VERSION,
+                            "TCG CPU version " QEMU_HW_VERSION,
                             &error_abort);
 }

@@ -8008,7 +8008,7 @@

     /* Hyper-V vendor id */
     if (!cpu->hyperv_vendor) {
-        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "Microsoft Hv",
+        object_property_set_str(OBJECT(cpu), "hv-vendor-id", "",
                                 &error_abort);
     }
     len = strlen(cpu->hyperv_vendor);
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -1618,7 +1618,7 @@
         c->function = HV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS;
         c->eax = hyperv_feat_enabled(cpu, HYPERV_FEAT_EVMCS) ?
             HV_CPUID_NESTED_FEATURES : HV_CPUID_IMPLEMENT_LIMITS;
-        memcpy(signature, "Microsoft VS", 12);
+        memset(signature, 0, 12);
         c->eax = 0;
         c->ebx = signature[0];
         c->ecx = signature[1];
@@ -1626,7 +1626,7 @@

         c = &cpuid_ent[cpuid_i++];
         c->function = HV_CPUID_SYNDBG_INTERFACE;
-        memcpy(signature, "VS#1\0\0\0\0\0\0\0\0", 12);
+        memset(signature, 0, 12);
         c->eax = signature[0];
         c->ebx = 0;
         c->ecx = 0;
@@ -2130,7 +2130,7 @@
 #ifdef CONFIG_XEN_EMU
         struct kvm_cpuid_entry2 *xen_max_leaf;

-        memcpy(signature, "XenVMMXenVMM", 12);
+        memset(signature, 0, 12);

         xen_max_leaf = c = &cpuid_data.entries[cpuid_i++];
         c->function = kvm_base + XEN_CPUID_SIGNATURE;
@@ -2206,7 +2206,7 @@
         abort();
 #endif
     } else if (cpu->expose_kvm) {
-        memcpy(signature, "KVMKVMKVM\0\0\0", 12);
+        memset(signature, 0, 12);
         c = &cpuid_data.entries[cpuid_i++];
         c->function = KVM_CPUID_SIGNATURE | kvm_base;
         c->eax = KVM_CPUID_FEATURES | kvm_base;
diff --git a/target/s390x/cpu_models.c b/target/s390x/cpu_models.c
--- a/target/s390x/cpu_models.c
+++ b/target/s390x/cpu_models.c
@@ -955,7 +955,7 @@
     S390CPUClass *xcc = S390_CPU_CLASS(oc);

     xcc->is_migration_safe = true;
-    xcc->desc = g_strdup_printf("QEMU Virtual CPU version %s",
+    xcc->desc = g_strdup_printf("CPU version %s",
                                 qemu_hw_version());
 }

diff --git a/target/s390x/tcg/misc_helper.c b/target/s390x/tcg/misc_helper.c
--- a/target/s390x/tcg/misc_helper.c
+++ b/target/s390x/tcg/misc_helper.c
@@ -331,18 +331,18 @@
             /* Basic Machine Configuration */
             char type[5] = {};

-            ebcdic_put(sysib.sysib_111.manuf, "QEMU            ", 16);
+            ebcdic_put(sysib.sysib_111.manuf, "AMD             ", 16);
             /* same as machine type number in STORE CPU ID, but in EBCDIC */
             snprintf(type, ARRAY_SIZE(type), "%X", cpu->model->def->type);
             ebcdic_put(sysib.sysib_111.type, type, 4);
             /* model number (not stored in STORE CPU ID for z/Architecture) */
-            ebcdic_put(sysib.sysib_111.model, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.sequence, "QEMU            ", 16);
-            ebcdic_put(sysib.sysib_111.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_111.model, "AMD             ", 16);
+            ebcdic_put(sysib.sysib_111.sequence, "AMD             ", 16);
+            ebcdic_put(sysib.sysib_111.plant, "AMD ", 4);
         } else if ((sel1 == 2) && (sel2 == 1)) {
             /* Basic Machine CPU */
-            ebcdic_put(sysib.sysib_121.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_121.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_121.sequence, "AMDAMDAMDAMDAMDA", 16);
+            ebcdic_put(sysib.sysib_121.plant, "AMD ", 4);
             sysib.sysib_121.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* Basic Machine CPUs */
@@ -357,8 +357,8 @@
     case STSI_R0_FC_LEVEL_2:
         if ((sel1 == 2) && (sel2 == 1)) {
             /* LPAR CPU */
-            ebcdic_put(sysib.sysib_221.sequence, "QEMUQEMUQEMUQEMU", 16);
-            ebcdic_put(sysib.sysib_221.plant, "QEMU", 4);
+            ebcdic_put(sysib.sysib_221.sequence, "AMDAMDAMDAMDAMDA", 16);
+            ebcdic_put(sysib.sysib_221.plant, "AMD ", 4);
             sysib.sysib_221.cpu_addr = cpu_to_be16(env->core_id);
         } else if ((sel1 == 2) && (sel2 == 2)) {
             /* LPAR CPUs */
@@ -366,7 +366,7 @@
             sysib.sysib_222.total_cpus = cpu_to_be16(total_cpus);
             sysib.sysib_222.conf_cpus = cpu_to_be16(conf_cpus);
             sysib.sysib_222.reserved_cpus = cpu_to_be16(reserved_cpus);
-            ebcdic_put(sysib.sysib_222.name, "QEMU    ", 8);
+            ebcdic_put(sysib.sysib_222.name, "AMD     ", 8);
             sysib.sysib_222.caf = cpu_to_be32(1000);
             sysib.sysib_222.dedicated_cpus = cpu_to_be16(conf_cpus);
         } else {
@@ -382,7 +382,7 @@
             sysib.sysib_322.vm[0].reserved_cpus = cpu_to_be16(reserved_cpus);
             sysib.sysib_322.vm[0].caf = cpu_to_be32(1000);
             /* Linux kernel uses this to distinguish us from z/VM */
-            ebcdic_put(sysib.sysib_322.vm[0].cpi, "KVM/Linux       ", 16);
+            ebcdic_put(sysib.sysib_322.vm[0].cpi, "AMDAMDAMD       ", 16);
             sysib.sysib_322.vm[0].ext_name_encoding = 2; /* UTF-8 */

             /* If our VM has a name, use the real name */
